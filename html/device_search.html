<FORM ACTION="<%$r->uri%>" METHOD="get">
<& SELF:matches &>
<h3>Device Search</h3>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 CLASS="box">
<TR>
    <TD ROWSPAN=9 WIDTH="8">&nbsp;</TD>
    <TD COLSPAN=4><h4>Search All</h4></TD>
    <TD ROWSPAN=9 WIDTH="8">&nbsp;</TD>
</TR>
<TR>
    <TD colspan=4>
        <INPUT TYPE="text" size=30 maxlength=60 NAME="text" VALUE="<%$text%>">
        <INPUT TYPE="submit" VALUE="Search All">
        <FONT size=-1>(non-exact)</font>
    </TD>
</TR> 
<TR>
    <TD COLSPAN=4><h4>Advanced Search</h4></TD>
</TR>
<TR>
    <TD> IP: </TD>
    <TD><INPUT TYPE="text" size=30 maxlength=60 NAME="ip" VALUE="<%$ip%>"></TD>
    <TD>Location:</TD>
    <TD><INPUT TYPE="text" size=30 maxlength=60 NAME="loc" VALUE="<%$loc%>"></TD>
</TR>
<TR>
    <TD> DNS: </TD>
    <TD><INPUT TYPE="text" size=30 maxlength=60 NAME="dns" VALUE="<%$dns%>"> </TD>
    <TD>Description: </TD>
    <TD><INPUT TYPE="text" size=30 maxlength=60 NAME="desc" VALUE="<%$desc%>"> </TD>
</TR>
<TR>
    <TD> Vendor:</TD>
    <TD><SELECT MULTIPLE NAME="vendors" size=<%scalar(keys %$vendors) > $winsize ? $winsize : scalar(keys %$vendors)%>>
%       foreach my $vendor (sort keys %$vendors){
            <OPTION VALUE="<%$vendor%>" <% grep(/^$vendor$/,@vendors) ? 'SELECTED' : ''%>><%$vendor%>
%       } 
        </SELECT></TD>
    <TD> Model:</TD>
    <TD><SELECT MULTIPLE NAME="models" SIZE=5>
%       foreach my $model (sort {lc($a) cmp lc($b)} keys %$models){
            <OPTION VALUE="<%$model%>" <% grep(/^$model$/,@models) ? 'SELECTED': ''%>><%$model%>
%       } 
        </SELECT></TD>
</TR>
<TR>
    <TD> Layer:</TD>
    <TD><SELECT MULTIPLE NAME="layers" size=<%$winsize%>>
%   foreach (1..7){ my $num=$_;
            <OPTION VALUE="<%$num%>" <% grep(/^$num$/,@layers) ? 'SELECTED' : ''%>><%$num%>
%   }
        </SELECT>
    </TD>
    <TD>OS:</TD>
    <TD VALIGN=TOP>
        <u>type</u> <SELECT MULTIPLE NAME="os" SIZE=<%scalar(keys %$oses) > $winsize ? $winsize : scalar(keys %$oses)%>>
% foreach my $this_os (sort keys %$oses) {
                   <OPTION VALUE="<%$this_os%>" <% grep(/^$this_os$/,@os) ? 'SELECTED' : ''%>><%$this_os%>
% }
               </SELECT>
        <u>version</u> <SELECT MULTIPLE NAME="os_ver" SIZE=<%scalar(keys %$os_vers) > $winsize ? $winsize : scalar(keys %$os_vers)%>>
% foreach my $this_os_ver (sort keys %$os_vers) {
                      <OPTION VALUE="<%$this_os_ver%>" <% grep(/^$this_os_ver$/,@os_ver) ? 'SELECTED' : ''%>><%$this_os_ver%>
% }
                  </SELECT>
    </TD>
</TR>
<TR>
    <TD> sysName: </TD>
    <TD><INPUT TYPE="text" size=30 maxlength=60 NAME="name" VALUE="<%$name%>"></TD>
    <TD VALIGN=TOP> Exact Match: </TD>
    <TD><INPUT TYPE="radio" NAME="exact" VALUE="1"<% $exact ? 'CHECKED' : ''%>>On
        <INPUT TYPE="radio" NAME="exact" VALUE="0"<% !$exact ? 'CHECKED' : ''%>>Off
    </TD>
</TR>
<TR>
    <TD COLSPAN=2><INPUT TYPE="submit" VALUE="Search"> [ <A href="<%$r->uri%>">Reset</A> ]</TD>
    <TD VALIGN=TOP>Match Scope: </TD>
    <TD><INPUT TYPE="radio" NAME="boolean" VALUE="or"<% $boolean eq 'or' ? 'CHECKED' : ''%>>Match Any
        <INPUT TYPE="radio" NAME="boolean" VALUE="and"<% $boolean eq 'and' ? 'CHECKED' : ''%>>Match All
        <BR>
        <font size=-1><B>*</B> and <B>?</B> are wildcards.  Non-exact assumes you want *<i>search</i>*</font>
    </TD>
</TR>
</TABLE>
</FORM>
<h4>Specific Searches</h4>
<FORM ACTION="<%$r->uri%>" METHOD="get">
<DL>
    <DT>
    <DD><INPUT TYPE="submit" name="specific" VALUE="Broken Topology Links">
    <DD><INPUT TYPE="submit" name="specific" VALUE="IP Phones discovered through SNMP">
    <DD><INPUT TYPE="submit" name="specific" VALUE="Devices without DNS entries">
    <DD><INPUT TYPE="submit" name="specific" VALUE="Device Aliases (IPs) without DNS entries">
    <DD><INPUT TYPE="submit" name="specific" VALUE="Devices orphaned by missing topology info">
    <DD><INPUT TYPE="submit" name="specific" VALUE="Device Ports with multiple nodes attached.">
    <DD><INPUT TYPE="submit" name="specific" VALUE="Device Ports that are blocking.">
    <DD><INPUT TYPE="submit" name="specific" VALUE="Ports Administratively disabled">
</DL>
</FORM>

<h4>Hints</h4>
<UL type=square>
    <LI>Matches on <u>DNS</u> or <u>IP</u> may be matching aliases <i>inside</i> those devices.
        Check inside the device for the matching entries.
    <LI>If you want to find blank entries, search on "is null" or conversely "is not null"
    <LI>You can select multiple for Model,Vendor,Layer, and OS by holding down CTRL as you click.
</UL>
<!-- took <%$time2 - $time1%> seconds to load -->
<%args>
@models   => ()
@layers   => ()
@vendors  => ()
@os       => ()
@os_ver   => ()
$ip       => ''
$text     => ''
$dns      => ''
$name     => ''
$desc     => ''
$boolean  => 'and'
$exact    => 0
$loc      => ''
$specific => undef
</%args>
<%shared>
my $matches = undef;
my $where = {};
my $awhere = {};
my $arg_exact;
my $winsize = 5;    # max size for select boxes.
</%shared>
<%init>
my $time1= time;

my $models  = sql_column('device',['distinct(model)', 'true']); 
my $vendors = sql_column('device',['distinct(vendor)','true']); 
my $oses    = sql_column('device',['distinct(os)',    'true']);
my $os_vers = sql_column('device',['distinct(os_ver)','true']);

$arg_exact = $exact;

# Specific Searches

#   Clear non-specific terms
if (defined $specific and length($specific)){
    @models = @layers = @vendors = undef;
    $ip = $text = $name = $desc = $loc = undef;
}

if ($specific =~ /alias/i){
    # Show these cols
    $where->{location}++;
    $where->{alias}++;
    $where->{name}++;
    $matches = sql_rows('device d left join device_ip i on d.ip = i.ip',
                        ['d.ip','d.dns','d.location','i.alias','d.name'],
                        {'i.dns' => 'is null','i.alias' => 'is not null'});

} elsif ($specific =~ /dns/i){
    $where->{vendor}++;
    $where->{model}++;
    $where->{location}++;
    $where->{name}++;
    $matches = sql_rows('device',
                        ['ip','vendor','model','location','name'],
                        {'dns' => 'is null'});

} elsif ($specific =~ /orphan/i){
    # Show these cols
    $where->{vendor}++;
    $where->{model}++;
    $where->{location}++;

    my $G = make_graph();
    my @S = $G->strongly_connected_components;

    # Find the strongly connected component that is biggest
    my $biggest = 0;
    for (my $sub = 0; $sub < @S; $sub++){
        $biggest = scalar @{$S[$sub]} > scalar @{$S[$biggest]} ?
                          $sub : $biggest;
    }

    my @orphans;
    for (my $j; $j < @S; $j++){
        next if $j == $biggest;
        push (@orphans,@{$S[$j]}); 
    }
    
    # This should be changed to a single SQL command

    while (my $orphan = shift @orphans ){
        my $match = sql_hash('device',['ip','dns','vendor','model','location'],
                              {'ip'=>$orphan});
        push (@$matches,$match) if defined $match;
    }
} elsif ($specific =~ /multiple/i){
    $where->{port}++;
    $where->{count}++;

    $matches = sql_rows('device_port d, node n, device i',
                        ['d.ip','i.dns','d.port','count(distinct(n.mac))'],
                        {'i.ip' => \'d.ip', 'd.ip' => \'n.switch', 'd.port' => \'n.port',
                         'd.remote_ip' => 'is null', 'n.active' => 1}, undef,
                        "group by d.ip,d.port,i.dns having count(distinct(n.mac)) > 1");
} elsif ($specific =~ /disabled/i){
    $where->{port}++;
    $where->{up_admin}++;

    $matches = sql_rows('device_port p, device d',
                        ['d.ip','d.dns','p.port','p.up_admin'],
                        {'d.ip' => \'p.ip', 'up_admin' => 'down'}
                       );
} elsif ($specific =~ /blocking/i){
    $where->{port}++;
    $where->{stp}++;
    $matches = sql_rows('device_port p, device d',
                        ['d.ip','d.dns','p.port','p.up_admin','stp'],
                        {'d.ip' => \'p.ip', 'stp' => 'broken','up' => 'up'}
                       );
    my $matches_blocking = sql_rows('device_port p, device d',
                        ['d.ip','d.dns','p.port','p.up_admin','stp'],
                        {'d.ip' => \'p.ip', 'stp' => 'blocking', 'up' => 'up'}
                       );

    push (@$matches,@$matches_blocking);
    
} elsif ($specific =~ /broken/i){
# select d.ip,d.dns,p.port,p.remote_ip,p.remote_port from device_port p , device d
#        where 
#           d.ip = p.ip 
#        and not exists 
#           (select 1 from device_port q where q.ip = p.remote_ip and q.port = p.remote_port) 
#        and not exists 
#           (select 1 from device_ip a, device_port q where a.alias = p.remote_ip and q.ip = a.ip and q.port = p.remote_port) 
#        and p.remote_ip is not null and p.remote_port is not null 
#        order by p.ip;
    $matches = sql_rows('device_port p, device d',
                           ['d.ip','d.dns','p.ip','p.port','p.remote_ip','p.remote_port','p.remote_type','p.remote_id'],
                           {'d.ip' => \'p.ip',
                            'not exists' => \\'(select 1 from device_port q where q.ip = p.remote_ip and q.port = p.remote_port)',
                            'not exists ' => \\'(select 1 from device_ip a, device_port q where a.alias = p.remote_ip and q.ip = a.ip and q.port = p.remote_port)',
                            'p.remote_ip' => \\'is not null', 'p.remote_port' => \\'is not null',
                            'p.remote_type' => \\ ' NOT ILIKE \'%ip_phone%\' OR p.remote_type IS NULL',
                           }
                          ); 
    $where->{port}++;
    $where->{remote_port}++;
    $where->{remote_ip}++;
    $where->{remote_id}++;
    $where->{remote_type}++;

} elsif ($specific =~ /ip.phone/i){
    $matches = sql_rows('device_port p, device d',
                           ['d.ip','d.dns','p.ip','p.port','p.remote_ip','p.remote_port','p.remote_type','p.remote_id'],
                           {'d.ip' => \'p.ip',
                            'not exists' => \\'(select 1 from device_port q where q.ip = p.remote_ip and q.port = p.remote_port)',
                            'not exists ' => \\'(select 1 from device_ip a, device_port q where a.alias = p.remote_ip and q.ip = a.ip and q.port = p.remote_port)',
                            'p.remote_ip' => \\'is not null', 'p.remote_port' => \\'is not null',
                            'p.remote_type' => \\ ' ILIKE \'%ip_phone%\'', 
                           }
                          ); 
    $where->{port}++;
    $where->{remote_port}++;
    $where->{remote_ip}++;
    $where->{remote_id}++;
    $where->{remote_type}++;
}

my @show_cols = ();

# Search on all text fields
if (length($text)) {
    $arg_exact = 0;
    my $match = $m->comp('.match', 'match' => $text);
    push(@{$where->{'d.dns/i.dns'}},  $match);
    push(@{$where->{'d.name'}}, $match);
    push(@{$where->{'d.description'}}, $match);
    push(@{$where->{'d.location'}}, $match);
    push(@{$where->{'d.serial'}}, $match);
    $boolean = 'or';
    $arg_exact = $exact;
}

# Generalized Search Terms

# Search on Model
foreach my $model (@models){
    next unless defined $model and length($model);
    if ($model eq 'show'){
        push (@show_cols,'d.model');
        next;
    }
    push (@{$where->{'d.model'}},$model);
}

# Search on OS
foreach my $this_os (@os){
    next unless defined $this_os and $this_os;
    if ($this_os eq 'show'){
        push (@show_cols,'d.os');
        next;
    }
    push (@{$where->{'d.os'}},$this_os);
}

# Search on OS Version
foreach my $this_ver (@os_ver){
    next unless defined $this_ver and $this_ver;
    if ($this_ver eq 'show'){
        push (@show_cols,'d.os_ver');
        next;
    }
    push (@{$where->{'d.os_ver'}},$this_ver);
}

# Search on Layers
my @layer_search = ('_','_','_','_','_','_','_');
# @layer_search is computer indexed, left->right
foreach my $layer (@layers){
    next unless defined $layer and length($layer);
    next unless ($layer > 0 and $layer < 8);
    $layer_search[$layer-1] = 1;
}
# the database field is in order 87654321
my $layer_string = join('', reverse @layer_search);
if ($layer_string =~ /1/){
    $layer_string = '%'.$layer_string;
    push (@{$where->{'d.layers'}},$layer_string);
}
# Search on Vendor
foreach my $vendor (@vendors){
    next unless defined $vendor and length($vendor);
    if ($vendor eq 'show'){
        push (@show_cols,'d.vendor');
        next;
    }
    push (@{$where->{'d.vendor'}},$vendor);
}


# Search on Location
if (length($loc)){
    my $match = $m->comp('.match', 'match' => $loc);
    push(@{$where->{'d.location'}}, $match);
}

# Search on Description
if (length($desc)){
    my $match = $m->comp('.match', 'match' => $desc);
    push(@{$where->{'d.description'}}, $match);
}

# Search on DNS entry
if (length($dns)){
    my $match = $m->comp('.match', 'match' => $dns);
    push(@{$where->{'d.dns/i.dns'}}, $match);
}

# Search on sysName
if (length($name)){
    my $match = $m->comp('.match', 'match' => $name);
    push(@{$where->{'d.name'}}, $match);
}

# Search on IP
if (length($ip)){
    my $match = $m->comp('.match', 'match' => $ip);
    push(@{$where->{'d.ip/i.alias'}}, $match);
    push(@show_cols,'d.name');
}

# Run Query
if (scalar keys %$where and ! defined $specific and ! length($specific)){
    #$matches = sql_rows('device',['*'],$where,$boolean eq 'or');

    my @cols = ();
    foreach my $wcol (keys %$where){
        foreach my $col (split('/',$wcol)) {
            # Skip the ones we're already selecting below
            next if ($col =~ /^i\./);
            next if ($col =~ /^d\.ip$/);
            next if ($col =~ /^d\.dns/);
            push(@cols,$col);
        }
    }

    # Add Columns to Grab info but not part of Search Terms
    foreach my $show (@show_cols){
        next if (grep /^$show$/,@cols);
        push @cols,$show;
    }

    $matches = sql_rows('device d left join device_ip i on d.ip = i.ip',
                        ['distinct(d.ip)','d.dns',@cols],
                        $where,
                        $boolean eq 'or');

    # Change col1/col2 to just col1 for display (implicit priority to col1)
    foreach my $wcol (keys %$where){
        if ($wcol =~ /^(.*)\/(.*)/){
            delete $where->{$wcol};
            push(@{$where->{$1}},undef); 
        }
    }
    # Add Info Columns to columns to display
    foreach my $w (@show_cols){
        next if (grep /^$w$/,keys(%$where));
        push(@{$where->{$w}},undef);
    }

}

my $time2 = time;
</%init>
%#
%# .match(match) - Formats the match term for SQL a bit.
%#
<%def .match>
<%args>
$match
</%args>
<%perl>
# Trim white space
$match =~ s/^\s+//;
$match =~ s/\s+$//;

# Leave IS (not) NULL queries alone
unless ($match =~ /^is\s+(not)?\s*null$/i){
    # Otherwise, make  * and ? into % and _
    $match =~ s/[*]+/%/g;
    $match =~ s/[?]/_/g;
    # Non-exact match means we add a * to both sides.
    $match = '%'. $match . '%' unless $arg_exact;
    $match =~ s/\%+/%/g;
}
return $match;
</%perl>
</%def>
%#
%# matches()  - Display search results stored in @$matches.
%#
<%method matches >
%return unless defined $matches;
<h3>Search Results</h3>
% unless (scalar @$matches) {
    No Results Found.
%    return;
% }
 <TABLE cellspacing=0 cellpadding=3 WIDTH=100%>
    <TR>
        <TH>Device</TH>
%    foreach my $col (sort keys %$where){
%       my $colview = $col;
%       $colview =~ s/^[^.]+\.//;
%       $colview = $colview eq 'count' ? 'Number of Active<BR>Nodes Connected' : $colview;
    <TH><%$colview%></TH>
%    }
    </TR>
<%perl>
my $count=0;
my @sort_matches = exists $where->{count} ? 
                     sort {$b->{count} <=> $a->{count} } @$matches :
                     sort {$a->{dns} cmp $b->{dns}} @$matches;
foreach my $result (@sort_matches){
   my $ip =  $result->{ip};
   my $dns = $result->{dns};
   my $port = $result->{port};
   $dns = defined $dns ? $dns : $ip;
   $dns =~ s/\Q$netdisco::CONFIG{domain}\E//;
   $dns .= " ($port)" if defined $port;
   $count++;
</%perl>
    <TR CLASS="match-<% $count % 2%>">
    <TD><A HREF="device.html?ip=<%$ip|u%><% defined $port ? '&port=' : ''%><% $port|u %>"><% $dns %></A></TD>
<%perl>
    foreach my $col (sort keys %$where){
        # Trim off table name for column
        $col =~ s/^[^.]+\.//;
        my $val = $result->{$col};

        # Column Specfic stuff
        if ($col eq 'remote_ip') {
            $val = "<A HREF=\"node.html?node=$val\">$val</A>";
        }
</%perl>
   <TD><%$val%></TD>
%    }
    </TR>
%}
  </TABLE>
<% $count %> matches.
</%method>
%#
%# title()
%#
<%method title>
- Device Search\
</%method>
%# $Id$
%# vim:syntax=mason
