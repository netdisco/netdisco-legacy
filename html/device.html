<H3>Device View</H3>
<& SELF:show_device &>
<h4>Device Search - Quick</h4>
<FORM ACTION="<%$r->uri%>" METHOD=GET>
Device name or IP :<INPUT TYPE="text" name="ip" maxlength=20 size=20>
<INPUT TYPE="submit" Value="Search">
<A HREF="<%$r->uri%>">[Reset Page]</A>
</FORM>
<h4>[<A href="device_search.html">Full Search</A>]</h4>
<%args>
$ip         => ''   # Can be IP or hostname
@port       => ()   # Ports to be shown
@portcol    => ()   # Columns to Show for each port
$submit     => ''   # Can have all/hide to control ports
$device_age => 'off'
$archive    => 'off'
$node_ip    => 'off'    # Show the IPs used by each MAC
$node_dns   => 'off'    # Resolve IPs of connected devices
$node_nbt   => 'off'    # Show the NetBIOS Name used by each MAC
</%args>
<%shared>
my ($arg_age,$arg_arch,$device,$devip,$arg_node_ip,
    $arg_node_dns,$arg_node_nbt);
my $ports = []; my $node_ips = {}; my $node_nbts = {};
my @arg_port;
my $domain = $netdisco::CONFIG{domain};
my $now    = time;
my $match  = 0;
my $odd    = 1;
# Change which columns are shown in ports by default.
my %port_cols = (
                 'descr'=>   ['Description',0],
                 'type' =>   ['Type',0],
                 'duplex' => ['Duplex<BR><font size=-2>(Link/Admin)</font>',1],
                 'speed' =>  ['Speed',1],
                 'name'  =>  ['Name',1],
                 'mac'   =>  ['Port MAC',0],
                 'mtu'   =>  ['MTU',0],
                 'vlan'  =>  ['VLAN',1],
                 'lastchange' => ['Last Change',0],
                 'stp' => ['Spanning Tree',0],
                );

my %device_info = (
                   'Addresses'  => 'addresses',
                   'First Discovered' => 'creation',
                   'Last MacSuck' => 'last_macsuck',
                   'Last ArpNip' => 'last_arpnip',
                   'Mac Address' => 'mac',
                   #'OSI Layers' => 'layers',
                   'VTP Domain' => 'vtp_domain',
                   #'Ports' => 'ports',
                   #'Backplane Slots' => 'slots',
                    );

# These are switches that we want a link to their web interface.
my $web_vendors  = $netdisco::CONFIG{web_console_vendors} || {};
my $web_models   = $netdisco::CONFIG{web_console_models} || {};
my $vlanctl      = $netdisco::CONFIG{vlanctl};
my $user         = $m->session->{user};
my $secure       = &is_secure;
my $port_ctl     = $m->session->{user_port_ctl};
my $port_control = ($port_ctl and $secure);
my $vlan_ctl     = ($port_ctl and $secure and $vlanctl);
my $port_info    = (defined $netdisco::CONFIG{port_info} and $netdisco::CONFIG{port_info} =~ /(1|t|T|y|Y)/) ? 1 : 0;
my $admin        = defined $m->session->{user_admin} and $m->session->{user_admin} ? 1 : 0;
</%shared>
<%init>
#  Parsing of Arguments
$arg_age  = $device_age; $arg_arch = $archive; 
@arg_port = @port; $arg_node_ip = $node_ip;
$arg_node_dns = $node_dns; $arg_node_nbt = $node_nbt;

if ($ip) {
    # Save Search Term
    $match = $ip;
    
    # Resolve input
    my $hostname = &hostname($ip);
    my $ip = &getip($ip);

    # Check if we're an alias of another device
    $devip = &root_device($ip);
    
    # redirect to search if no match
    $m->redirect("device_search.html?text=$match") unless $devip;

    # Grab Device INFO
    $device = sql_hash('device',
                        ['ip','extract(epoch from creation) as creation','dns',
                         'description','uptime','contact','name','location','layers',
                         'ports','mac','serial','model','ps1_type','ps2_type','ps1_status',
                         'ps2_status','fan','slots','vendor','log','os_ver','os','vtp_domain',
                         'extract(epoch from last_discover) as last_discover',
                         'extract(epoch from last_macsuck) as last_macsuck',
                         'extract(epoch from last_arpnip) as last_arpnip' ],
                        {'ip'=>$devip});


    # This could take a while.
    $m->flush_buffer();

    # Grab addresses  
    my $addresses = sql_rows('device_ip',['alias','dns','port','subnet'],
                           {'ip'=>$devip});
    # Sort Aliases by Port
    my $port_addresses = {};
    foreach my $a (@$addresses) {
        push @{$port_addresses->{$a->{port}}},$a; 
    }

    $device->{addresses} = $addresses;
    
    # Hide Ports
    if ($submit =~ /hide/i) {
        @port = @arg_port = (); 
    } 

    # All Ports
    if ($submit =~ /all/i or grep(/^all$/,@port)){
        @arg_port = @port = ('all'); 
        $ports = sql_rows('device_port',['*'],{'ip'=>$devip}) || [];         
    } 

    # Selected Ports 
    else {
        foreach my $portreq (@port) {
            next unless defined $portreq;
        
            my $db_ports = sql_rows('device_port',['*'],
                            {'ip'=>$devip,'port'=>$portreq});

            # add our results to the list
            if (defined $db_ports and scalar @$db_ports){
                push (@$ports,@$db_ports);
            }
        }
    }

    # PORTS - Connected Nodes, addresses and log entries
    foreach my $portreq (@$ports) {
        my $switch = $portreq->{ip};
        my $port   = $portreq->{port}; 
        $portreq->{portdisp} = $portreq->{port}; 

        # Get count of log entries for this port
        $portreq->{logs} = sql_scalar('device_port_log',['count(id)'],{'ip'=>$switch,'port'=>$port});

        # Get Nodes Attached
        my $nodes = sql_rows('node',
            ['mac','active','extract (epoch from time_first) as time_first',
             'extract (epoch from time_last) as time_last'],
            {'switch' => $switch, 'port' => $port } );
        $portreq->{macs} = (defined $nodes and scalar @$nodes) ? $nodes : undef;

        # Get SSIDs
        my $ssids = sql_rows('device_port_ssid',['*'],{'ip'=>$switch,'port'=>$port});
        $portreq->{ssids} = (defined $ssids and scalar @$ssids) ? $ssids : undef;

        # Save MAC addresses for IP lookup
        foreach my $node (@$nodes){
            my $mac = $node->{mac};
            $node_ips->{$mac}++;
            $node_nbts->{$mac}++;
        }

        # Add addresses to display of port name
        my $addresses = $port_addresses->{$port} || [];
        foreach my $alias ( sort {sort_ip($a->{alias},$b->{alias})} @$addresses ) {
                my $alias_ip = $alias->{alias};
                my $alias_subnet = $alias->{subnet};
                my $dns = $alias->{dns} || '[No DNS]';
                $dns =~ s/\Q$domain\E//;
                $portreq->{portdisp} .= "<BR> $alias_ip - $alias_subnet ($dns)";
        }

    }

    # Get IP addresses of connected nodes
    if ($node_ip eq 'on'){
        my @macs = keys %$node_ips;
        my $ips = sql_rows('node_ip',['mac','ip'],
                           {active => 1, mac => [\@macs] }
                          );
        $node_ips = {};
        # Push IP address into list in %node_ips hash
        foreach my $macip (@$ips){
            my $mac = $macip->{mac};
            my $ip  = $macip->{ip};
            push ( @{$node_ips->{$mac}},$ip);
        }
    }

    # Get NetBIOS addresses of connected nodes
    if ($node_nbt eq 'on'){
        my @macs = keys %$node_nbts;
        my $nbts = sql_rows('node_nbt',['mac','nbname','domain','user','ip'],
                           {active => 1, mac => [\@macs] }
                          );
        $node_nbts = {};
        # Push IP address into list in %node_nbts hash
        foreach my $macnbt (@$nbts){
            my $mac = $macnbt->{mac};
            push ( @{$node_nbts->{$mac}},$macnbt);
        }
    }

    # Resolve IPs of connected nodes to host names
    if ($node_ip eq 'on' and $node_dns eq 'on'){

    }
}

# Change the columns of ports shown
if (scalar @portcol and join('',@portcol) !~ /^\s*$/) {
    # Set all to not seen
    foreach my $key (keys %port_cols){
        $port_cols{$key}->[1] = 0;
    }

    # show the ones we want
    foreach my $col (@portcol) {
        # Check for funny things passed
        next unless defined ($port_cols{$col});

        # Set the passed one as shown
        $port_cols{$col}->[1] = 1;
    }
}
</%init>
%#
%# END MAIN COMPONENT
%#
%# port_view() - Prints out the Port View control form
%#
<%method port_view>
<h4>Port View</h4>
<FORM ACTION="<%$r->uri%>" METHOD="get">
<INPUT TYPE="hidden" NAME="ip" VALUE="<%$devip%>">
% foreach my $port (@arg_port){
    <INPUT TYPE="hidden" NAME="port" VALUE="<%$port%>">
%}
<INPUT TYPE="submit" VALUE="Show All Ports" NAME="submit" >
% if (defined $ports and scalar @$ports) {
<INPUT TYPE=SUBMIT VALUE="Hide Ports">
% }
<P>
<B>Columns:</B>
% foreach my $col (keys %port_cols) {
%   my $name  = $port_cols{$col}->[0];
%   my $check = $port_cols{$col}->[1];
%   $name =~ s/<BR>.*$//;
   <%$name%><INPUT TYPE="checkbox" NAME="portcol" VALUE="<%$col%>" <%$check ? 'CHECKED' : ''%>>&nbsp;
% }
<BR>
<B>Connected Device Age Stamp</B>:
<INPUT TYPE="radio" NAME="device_age" VALUE="off" <%$arg_age eq 'off' ? 'CHECKED' : '' %>>Off
<INPUT TYPE="radio" NAME="device_age" VALUE="on"  <%$arg_age eq 'on'  ? 'CHECKED' : '' %>>On
&nbsp; &nbsp; &nbsp; &nbsp;
<B>Show Archived Data</B>:
<INPUT TYPE="radio" NAME="archive" VALUE="off" <%$arg_arch eq 'off' ? 'CHECKED' : '' %>>Off
<INPUT TYPE="radio" NAME="archive" VALUE="on"  <%$arg_arch eq 'on'  ? 'CHECKED' : '' %>>On
<BR>
<B>Show Connected Device IP</B>:
<INPUT TYPE="radio" NAME="node_ip" VALUE="off" <%$arg_node_ip eq 'off' ? 'CHECKED' : '' %>>Off
<INPUT TYPE="radio" NAME="node_ip" VALUE="on"  <%$arg_node_ip eq 'on'  ? 'CHECKED' : '' %>>On
&nbsp; &nbsp; &nbsp; &nbsp;
<B>Resolve IPs</B>
<INPUT TYPE="radio" NAME="node_dns" VALUE="off" <%$arg_node_dns eq 'off' ? 'CHECKED' : '' %>>Off
<INPUT TYPE="radio" NAME="node_dns" VALUE="on"  <%$arg_node_dns eq 'on'  ? 'CHECKED' : '' %>>On
<BR>
<B>Show Connected Device NetBIOS</B>
<INPUT TYPE="radio" NAME="node_nbt" VALUE="off" <%$arg_node_nbt eq 'off' ? 'CHECKED' : '' %>>Off
<INPUT TYPE="radio" NAME="node_nbt" VALUE="on"  <%$arg_node_nbt eq 'on'  ? 'CHECKED' : '' %>>On
<BR>
<INPUT TYPE="submit" VALUE="Change View" NAME="submit">
</FORM>
</%method>
%#
%# show_device() - Display device Info.
%#
<%method show_device>
<%perl>
return unless defined $device;

my $dns = $device->{dns} || '[No DNS]';
my $vendor = $device->{vendor};
my $model  = $device->{model};
my $want_web_link = (defined $web_vendors->{$vendor} or defined $web_models->{$model});
my $web_dns = $dns;
$web_dns =~ s/\Q$domain\E//;
</%perl>
<B><%$dns%></B> (<%$devip%>)
% if ($want_web_link or $admin) {
<BR>
%}
% if ($want_web_link) {
[<A HREF="switch/<%$web_dns|u%>/">Web Console</A>]
% } 
% if ($admin) {
[<A HREF="admin_dev.html?dev=<%$devip |u%>">Device Control</A>]
% }
<HR NOSHADE>
<TABLE CELLSPACING=0 CELLPADDING=3 BORDER=0>
<TR CLASS="match-<%++$odd %2%>">
    <TD><U>Name</U></TD>
    <TD ALIGN=LEFT><%$device->{name}|h%></TD>
</TR>
<TR CLASS="match-<%++$odd %2%>">
    <TD><U>Location / Contact</U></TD>
    <TD ALIGN=LEFT><%$device->{location} || '[Not Set]' |h%>
        / <%$device->{contact} || '[Not Set]' |h%>
    </TD>
</TR>
<TR CLASS="match-<%++$odd %2%>">
    <TD><U>Model / Serial</U></TD>
    <TD ALIGN=LEFT><A HREF="device_search.html?vendors=<%$device->{vendor}|u%>&models=<%$device->{model}|u%>&boolean=and" TITLE="List All Devices of this type."><%$device->{vendor}%> <%$device->{model}%></A>
    / <%$device->{serial} || 'Unknown'%>
    </TD>
</TR>
<TR CLASS="match-<%++$odd %2%>">
    <TD><U>OS / Version</U></TD>
    <TD ALIGN=LEFT><A HREF="device_search.html?os=<%$device->{os} || 'is null' |u%>" TITLE="List Devices running this OS."><%$device->{os} || 'Unknown'%></A> /
                   <A HREF="device_search.html?os=<%$device->{os} || 'is null' |u%>&os_ver=<%$device->{os_ver} || 'is null' |u%>&boolean=and"i TITLE="List devices with this OS Version"><%$device->{os_ver} || 'Unknown'%></A>
    </TD>
</TR>
<TR CLASS="match-<%++$odd %2%>">
    <TD><U>Description</U></TD>
    <TD ALIGN=LEFT><%$device->{description}|h%></TD>
</TR>
<TR CLASS="match-<%++$odd %2%>">
    <TD><U>Uptime</U>/<BR><U>Last Discovered</U></TD>
    <TD ALIGN=LEFT><% $m->comp('SELF:uptime', uptime => $device->{uptime})%> 
    / <% scalar localtime($device->{last_discover}) %>
    </TD>
</TR>
% if (defined $device->{fan} or $device->{ps1_status}) {
<TR CLASS="match-<%++$odd %2%>">
    <TD><U>Power</U></TD>
    <TD ALIGN=LEFT>
%   if (defined $device->{fan}) {
    Fan : <%$device->{fan}%> &nbsp;&nbsp;
% }
%   if (defined $device->{ps1_status}) {
    PS1 [<%$device->{ps1_type}%>] :  <%$device->{ps1_status}%>&nbsp;&nbsp;
% }
%   if (defined $device->{ps2_status}) {
    PS2 [<%$device->{ps2_type}%>] :  <%$device->{ps2_status}%>&nbsp;&nbsp;
% }

    </TD>
</TR>
% }
<%perl>
# Print out each item in the database that we have using the 
#   %device_info map.
foreach my $item (sort keys %device_info) {
    my $db_col = $device_info{$item};
    my $val = $device->{$db_col};
    next unless defined $val and length($val);

    # Munge
    if ($db_col eq 'addresses'){
        next unless scalar @$val;
        my @vals;
        foreach my $alias (sort { sort_ip($a->{alias}, $b->{alias}) } @$val){
            my $ip = $alias->{alias};
            my $dns = $alias->{dns};
            $dns = defined $dns ? $dns :
                    '[No DNS]';
            $dns =~ s/\Q$domain\E//;
            my $port = $alias->{port};
            my $subnet = $alias->{subnet};
            push (@vals, "$ip ($dns) \@ $port - $subnet");
        }
        $val = join("<BR>",@vals);
    }
    if ($db_col eq 'creation') {
        $val = localtime($val);
    }
    if ($db_col eq 'last_discover') {
        $val = localtime($val);
    }
    if ($db_col eq 'last_macsuck') {
        $val = localtime($val);
    }
    if ($db_col eq 'last_arpnip') {
        $val = localtime($val);
    }

    my $match_class = ++$odd % 2;
    $m->out("<TR CLASS=\"match-$match_class\"><TD ALIGN=CENTER><u>$item</u></TD>");
    $m->out("<TD ALIGN=LEFT>$val</TD></TR>\n");
}
# Treat the log a little different
my $log = $device->{log};
if (defined $log and length($log)){
    my $logclass = ++$odd % 2;
</%perl>
<TR CLASS="match-<%$logclass%>">
    <TD ALIGN=CENTER><u>Log</u></TD>
    <TD ALIGN=LEFT><TEXTAREA ROWS=3 COLS="50" WRAP="soft"><%$log|h%></TEXTAREA></TD>
</TR>
%}
</TABLE>
<& SELF:show_ports &>
</%method>
%#
%# port_header() - Prints out the header block depending on the columns selected
%#
<%method port_header>
<TR>
    <TH>Port</TH>
% foreach my $col (sort keys %port_cols){
%   my $desc = $port_cols{$col}->[0];
%   my $on   = $port_cols{$col}->[1];
%   next unless $on;
    <TH><%$desc%></TH>
%}
    <TH>Connected<BR>Devices<% $arg_age eq 'on' ? '<BR><font size=-2>(Last Seen)</font>' : ''%></TH>
%# if ($port_control) {
    <TH>Port<BR>Control</TH>
%#}
</TR>
</%method>
%#
%# show_ports()
%#
<%method show_ports>
<%perl>
# No ports specified
unless (scalar @$ports) { 
    $m->comp('SELF:port_view' );
    return;
}

# Ports Found
my $link = $r->uri() . "?ip=$devip";

</%perl>
<TABLE cellspacing=0 cellpadding=3 border=1>
<& SELF:port_header &>
<%perl>
# Display the Ports
foreach my $port (sort sort_port @$ports){
    my $remote_ip   = $port->{remote_ip};
    my $remote_port = $port->{remote_port};
    my $remote_id   = $port->{remote_id};
    my $remote_type = $port->{remote_type};
    my $up_admin    = $port->{up_admin} || '';
    my $stp         = $port->{stp}      || '';
    my $up          = $port->{up}       || '';

    # An uplink is a port that has a remote_ip but is not a phone
    #   We do _not_ allow shutdown of ports that have remote info but are not
    #   in our database. Consider an SNMP problem.  Or consider your routes off-site
    #   where your ISP might squawk CDP, but we don't have SNMP.  We don't want to
    #   allow people to turn those off.
    my $is_uplink   = (defined $remote_ip and !(defined $remote_type and $remote_type =~ /ip.phone/i)) ? 1 : 0;
    my $class = $up eq 'down' ? 'port-down' : 'port-up';
    $class    = $up_admin eq 'down' ? 'port-off' : $class;
    # Check for STP blocking, but not down
    $class    = ($up ne 'down' and $stp =~ /(blocking|broken)/) ? 'port-block' : $class;
    my $rowclass = (++$odd % 2 ) ? 'match-0': 'match-1';
</%perl>
<TR CLASS="<%$rowclass%>">
    <TD CLASS="<%$class%>"><% $port->{portdisp} %></TD>
<%perl>
    foreach my $col (sort keys %port_cols){
        my $colname  = $port_cols{$col}->[0];
        my $colcheck = $port_cols{$col}->[1];
        next unless $colcheck;
        my $val = $port->{$col};
        # Munge Port Columns
        if ($col eq 'duplex') {
            $val = defined $val ? $val : '[NA]';
            my $duplex_admin = $port->{duplex_admin};
            $duplex_admin = defined $duplex_admin ? $duplex_admin :
                '[NA]';
            $val .=  "/$duplex_admin";
        }
        if ($col eq 'lastchange'){
            # lastchange is a timestamp of the sysUpTime
            # we subtract it from the current uptime to find out how many
            # seconds*100 it was, then we subtract that from the current time to
            # see when that was.
            my $diff_sec = ($device->{uptime} - $val) / 100;  
            $val = scalar localtime($device->{last_discover} - $diff_sec);
        }
</%perl>
        <TD CLASS="<%$class%>"><% $val || '' |h %></TD>
%    }
% # Connected Devices Column
        <TD ALIGN=LEFT>
<%perl>
    # CDP speaking device connected
    if (defined $remote_ip) {
        my $name = '';
        my $link = '';
        my $remote_dev = sql_hash('device',['ip','dns'],
                    {'ip'=>$remote_ip});
        my $alias = sql_hash('device_ip',['ip','dns'],
                    {'alias'=>$remote_ip});
        # Resolve IP address squawked to root device
        if (defined $alias) {
            $remote_ip = $alias->{ip};
            $name = $alias->{dns};
            $name = defined $name ? $name  : $remote_ip; 
            $name =~ s/\Q$domain\E//;
            $name .= " ($remote_port)";
            $name = "<SPAN CLASS=\"device-link\">$name</SPAN>";
            $link = "device.html?ip=$remote_ip&port=$remote_port";

        # Not an alias, use info from device table
        } elsif (defined $remote_dev) {
            $name = $remote_dev->{'dns'};
            $name = defined $name ? $name  : $remote_ip; 
            $name =~ s/\Q$domain\E//;
            $name .= " ($remote_port)";
            $name = "<SPAN CLASS=\"device-link\">$name</SPAN>";
            $link = "device.html?ip=$remote_ip&port=$remote_port";

        # Found a device, but not in our database
        } else {
            if ($arg_node_dns eq 'on') { 
                $name = hostname($remote_ip) || $remote_ip;
                $name =~ s/\Q$domain\E//; 
            } else {
                $name = $remote_ip;
            }
            my $spanclass = (defined $remote_type and $remote_type =~ /ip.phone/i) ?
                'ip-phone' : 'dead-link';
            $name = "<SPAN CLASS=\"$spanclass\">$name</SPAN>";
            $name .= " ($remote_port)";
            $name .= "<BR>&nbsp;&nbsp;&nbsp;($remote_type)" if defined $remote_type;
            $name .= "/($remote_id)" if defined $remote_id;
            $link = "node.html?node=$remote_ip";
        }
</%perl>
            <A HREF="<%$link%>"><%$name%></A> \
<%perl>
    } 

    # Show SSIDs
    my $portssids = $port->{ssids} || [];
    foreach my $ssid (@$portssids) {
        my $id = $ssid->{ssid};
        my $bcast = $ssid->{broadcast} ? "(B)" : "";
</%perl>
        <BR>SSID: <%$id%> <%$bcast%>
<%perl>
    }

    $m->out("<BR>\n") if ((defined $remote_ip or defined $port->{ssids}) and defined $port->{macs});

    # Show connected nodes
    my $seen_macs=0;
    my $portnodes = $port->{macs} || [];
    foreach my $node (sort {$a->{mac} cmp $b->{mac}} @$portnodes) {
        my $mac       = $node->{mac};
        my $active    = $node->{active};
        my $time_last = $node->{time_last};

        # Connected Device Age Stamp?
        my $age = $now - $time_last;
        $age = sprintf("%d", ($age / (60*60*24)));
        my $show_age  = ($arg_age eq 'on' and $age > 0) ? " ($age days)" : '';

        # Show Archived Data?
        next unless ($active or $arg_arch eq 'on');
        $seen_macs++;
</%perl>
        <A HREF="node.html?node=<% $mac |u %>" TITLE="Node Info"><% $mac%></A><%$show_age%><% $active ? '' : '*'%><BR>
<%perl>
        # Show node_ips?
        if ($arg_node_ip eq 'on' and defined $node_ips->{$mac}) {
            foreach my $ip (sort sort_ip @{$node_ips->{$mac}}) {
                # Show Node DNS ?
                my $host = $ip;
                if ($arg_node_dns eq 'on'){ 
                    $host = hostname($ip) || $ip;
                    $host =~ s/\Q$domain\E//; 
                    # Add IP if we found a hostname. 
                    $host .= " ($ip)" if ($host ne $ip);
                }
</%perl>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="node.html?node=<% $ip |u %>" TITLE="Node Info"><%$host%></A><BR>
<%perl>
           }   # /each node_ip
        } # /if node_ip
        # Show node_nbts?
        if ($arg_node_nbt eq 'on' and defined $node_nbts->{$mac}) {
            foreach my $nbt (sort @{$node_nbts->{$mac}}) {
</%perl>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\\<A HREF="ip_search.html?domain=<%$nbt->{domain}|u%>&cmd=nbt" TITLE="Devices in this Domain"><%$nbt->{domain}%></A>\<A HREF="node.html?node=<% $nbt->{nbname} |u %>"><%$nbt->{nbname}%></A><BR>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<%$nbt->{nbuser} || '[No User]'%>@<A HREF="node.html?node=<%$nbt->{ip}|u%>"><%$nbt->{ip}|h%></A><BR>

<%perl>
           }   # /each node_nbt
        } # /if node_nbt
    } # /each node

    # Place holder for no connected devices
    unless ($seen_macs or defined $remote_ip) {
        $m->out('&nbsp;');
    }
# end connected dev col.
</%perl>
            </TD>    
% # Port Control Column
    <TD> \
% if ($device->{dns} =~ /^hub/i and $port_info) {
      <A HREF="port_info.html?hub=<%$device->{dns}%>&port=<%$port->{port}%>"><IMG SRC="icon_info.gif" WIDTH=12 HEIGHT=11 BORDER=0 ALT="Pinnacles DB Info" TITLE="Pinnacles DB Info"></A> \
% }
%     if ($port->{logs}){
        <A HREF="portcontrol.html?cmd=log&ip=<%$port->{ip} |u%>&port=<%$port->{port} |u%>"><IMG SRC="icon_note.gif" ALT="<%$port->{logs}%> Admin Log Entries" TITLE="<%$port->{logs}%> Admin Log Entries" BORDER=0></A> \
%     } 
% if ($port_control and !$is_uplink) {
%   my $dir = $port->{up_admin} eq 'down' ? 'up' : 'down';
    <A HREF="portcontrol.html?cmd=<%$dir%>&ip=<%$port->{ip} |u%>&port=<%$port->{port} |u%>"><IMG SRC="icon_<%$dir%>.gif" ALT="Bring Port <%$dir%>" TITLE="Bring Port <%$dir%>" BORDER=0></A> \
%   if ($vlan_ctl) {
    <A HREF="portcontrol.html?cmd=vlan&ip=<%$port->{ip} |u%>&port=<%$port->{port} |u%>"><IMG SRC="icon_v.gif" ALT="Change VLANs" TITLE="Change VLANs" BORDER=0></A> \
%   }
% } elsif (! $port->{logs}){
&nbsp; \
%     }
    </TD>
</TR>
% }  # end foreach port
% 
% # Print out the legend again if we have lots of results
% $m->comp('SELF:port_header') if (scalar @$ports > 10);
% 
<& SELF:port_key &>
<& SELF:port_view &>
</%method>
<%method port_key>
</TABLE>
<h4>Key</h4>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR CLASS="tr-data-1">
    <TD>Ports:</TD>
    <TD>
    [<SPAN CLASS="port-off">Admin Disabled</SPAN>]
    [<SPAN CLASS="port-down">Link Down</SPAN>]
    [<SPAN CLASS="port-block">Blocking</SPAN>]
    [<SPAN CLASS="ip-phone">IP Phone</SPAN>]
    (<SPAN CLASS="dead-link">Discovered Neighbor not accessible</SPAN>)
    </TD>
</TR>
% if ($port_control) { 
<TR CLASS="tr-data-2">
    <TD>Admin :</TD>
    <TD>
    <NOBR><IMG SRC="icon_note.gif" BORDER=0> Log </NOBR>
    <NOBR><IMG SRC="icon_up.gif" BORDER=0> Enable </NOBR>
    <NOBR><IMG SRC="icon_down.gif" BORDER=0> Disable </NOBR>
    <NOBR><IMG SRC="icon_v.gif" BORDER=0> VLAN</NOBR> 
% if ($port_info) {
    <NOBR><IMG SRC="icon_info.gif" BORDER=0> Pinnacle DB Info</NOBR> 
% }
    </TD>
</TR>
%}
% if ($arg_arch eq 'on' or $arg_age eq 'on'){
<TR CLASS="tr-data-1">
    <TD>Settings :</TD>
    <TD>
    <Font size=-2>Entries without timestamps are less than 1 day old.</font>
    <BR>* denotes archived data
    </TD>
</TR>
% }
</TABLE>
</%method>
%#
%# uptime() - Returns pretty-print of uptime values
%#
<%method uptime>
<%args>
$uptime
</%args>
<%perl>
# uptime is in 100ths of seconds
my $val = int($uptime/100);
my $sec = $val % 60;
$val = ( $val - $sec ) / 60;
my $min = $val % 60;
$val = ( $val - $min ) / 60;    
my $hour = $val % 24;
$val = ( $val - $hour ) / 24;
my $day = $val % 7;
my $week = ($val - $day) / 7;
my @times;
push (@times,"$week weeks") if $week;
push (@times,"$day days") if ($week or $day);
push (@times,"$hour hours") if ($week or $day or $hour);
push (@times,"$min min.") if ($week or $day or $hour or $min);
return join(',',@times);
</%perl>
</%method>
<%method title>
- Device View \
</%method>
%# $Id$
%# vim:syntax=mason
