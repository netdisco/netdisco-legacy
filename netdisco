#!/usr/bin/perl -w
# n e t  d i s c o
# Created for UCSC
# Changes from 0.92 on (C) 2003,2004 Max Baker - All rights Reserved.
# (C) 2002,2003 UC Regents.  See bottom of this file.
# $Id$

=head1 NAME

netdisco - Internal API

=head1 DESCRIPTION

This is the inside guts of the Netdisco executable.  You should be looking in 
README for how to use Netdisco.

=cut

use strict;
use Getopt::Long;
use FindBin;             # Add this directory for netdisco.pm
use lib $FindBin::Bin;
use IO::File;            # For batch_mode()
use POSIX qw/:errno_h/;  # for Admin Daemon
use SNMP::Info 0.9;
use netdisco qw/:all/;  
use Socket qw/:all/;

$| = 1;

# Signal Handlers
$SIG{INT}  = \&end_int_handler;
$SIG{ALRM} = \&timeout;

# --------------------------------------------------------------
#                         Globals                               
# --------------------------------------------------------------
use vars qw/$DEBUG %CONFIG %Discovered %Discovered_Alias @Discover_Queue %NoCDP %UnDiscovered
            %TimedOut $Aliases $OldDevices $OldNodes $PortMAC $start_time $end_time $ArpTotal $NbtTotal %MacSeen
            $MacTotal @OldSTDOUT @LogFH @LogFile %DeviceTopo %args $configfile $BatchMode $Log
            $New_Only $VERSION $DaemonMode/;

$VERSION = '0.94-cvs';
%Discovered = ();
%Discovered_Alias = ();
@Discover_Queue = ();
%NoCDP = ();
%UnDiscovered = ();
%TimedOut = ();
$Aliases = undef;
$OldDevices = undef;
$PortMAC = undef;
$DaemonMode=$start_time=$end_time=0;
$ArpTotal = 0;
$NbtTotal = undef;
%MacSeen = ();
$MacTotal = 0; 
@OldSTDOUT = ();
@LogFH     = ();
@LogFile   = ();
%DeviceTopo = ();

# --------------------------------------------------------------
#              Command Line Flags                               
# --------------------------------------------------------------
Getopt::Long::Configure('no_ignore_case');
GetOptions(\%args,'a|arpwalk',
                  'A|arpnip=s',
                  'b|batchmode',
                  'B|backup',
                  'C|configfile=s',
                  'd|discover=s',
                  'D|debug',
                  'e|expirenodes=s',
                  'E|expiredevice=s',
                  'expire-nodes-subnet=s',
                  'F|discoverfile=s',
                  'g|graph',
                  'h|help',
                  'I|expireips',
                  'i|changeip=s',
                  'k|cleanalias',
                  'K|cleannodes',
                  'L|nologging',
                  'm|macwalk',
                  'M|macsuck=s',
                  'n|nodestoo',
                  'N|newonly',
                  'O|oui',
                  'P|port=s',
                  'p|daemon=s',
                  'r|discoverall=s',
                  'S|dumpsql',
                  'R|refresh',
                  't|test',
                  'T|topofile',
                  'u|user',
                  'v|version|ver',
                  'V|archive',
                  'w|nbtwalk',
                  'W|nbtstat=s',
          );
$DEBUG             = $args{D} || 0;
$netdisco::SQLCARP = $args{S} || 0;
$BatchMode         = $args{b} || 0;
$New_Only          = $args{N} || 0;
$Log               = (!$BatchMode and ($DEBUG or defined $args{L})) ? 0 : 1;

# Allow the -h or -v commands to run no matter what
defined $args{h} and &usage;
defined $args{v} and &version;

# Print Header
&header if (grep(/^([aABdeEFgIikKmMOprRTu]|expire-nodes-subnet)$/,keys %args) and !$BatchMode);

# Parse Config File - Check for -C, then in current dir, then in default dir.
foreach my $c ($args{C},"$FindBin::Bin/netdisco.conf",'/usr/local/netdisco/netdisco.conf') {
    if (defined $c and -r $c){
        $configfile = $c;
        print "Using Config File : $configfile\n" if $DEBUG;
        last;
    }
}

unless (defined $configfile){
    print "No Config file found!\n";
    exit;
}

config($configfile);

# --------------------------------------------------------------
#             Run Commands                                      
# --------------------------------------------------------------

#   Discovery
defined $args{R} and &refresh_all;
defined $args{d} and &topo_load_file;
defined $args{d} and &discover($args{d});
defined $args{r} and &run($args{r});
if (defined $args{F} or defined $args{T}) {
    &schlop( defined $args{F} ? $args{F} : "$CONFIG{home}/$CONFIG{topofile}", 
             defined $args{T}
           );
}

#   Mac Sucking
defined $args{M} and &macsuck($args{M});
defined $args{m} and &macwalk;

#   Arp Nipping
defined $args{a} and &arpwalk;
defined $args{A} and &arpnip($args{A});

#   NetBIOS
defined $args{w} and &nbtwalk;
defined $args{W} and &nbtstat($args{W});

#   Other
defined $args{K} and &db_clean;
defined $args{k} and &alias_clean;
defined $args{g} and &graph;
defined $args{t} and &test;
defined $args{O} and &parse_oui;
defined $args{B} and &nightly;
defined $args{E} and &expire_device($args{E},defined $args{n});
defined $args{e} and &expire_nodes($args{e},defined $args{V},$args{P});
defined $args{I} and &expire_ips;
defined $args{i} and &change_device_ip($args{i},shift @ARGV);
defined $args{p} and &admin_daemon_ctl($args{p});
defined $args{u} and &add_user;
defined $args{'expire-nodes-subnet'} and &expire_nodes_subnet($args{'expire-nodes-subnet'});

# Make sure we ran a command, else spit out the usage
&usage unless ( grep(/^([aABdeEFgiIkKmMnNOprRtTuwW]|expire-nodes-subnet)$/,keys %args) );
exit;

=head1 FUNCTIONS

=head2 Network Discovery

=over

=item discover(host) 

Discovers one device, stores its info, interfaces, and neighbors, and returns.

=cut
sub discover{
    my $hostname = shift;

    print "Discover($hostname) : ";

    my $ip = getip($hostname);
    if (in_subnets($ip,'discover_no')) {
        print " Excluded from discovery in config file.\n";
        return;
    }

    my $device = get_device($hostname) or return;
    $ip        = $device->{ip};

    # Store Device Info
    store_device($device);

    # Walk Interfaces
    store_interfaces($device);

    # Walk Modules

    # Walk neighbors
    find_neighbors($device);

    # Manual Topology Info
    topo_add_link( $DeviceTopo{$ip} ) if defined $DeviceTopo{$ip}; 

    $Discovered{ $ip }++;

    foreach my $alias (keys %{$device->{_alias}}){
        next unless defined $alias and length($alias);
        $Discovered_Alias{ $alias }++;
    }
}

=item refresh_all()

Calls discover() for each file already in device table.

=cut
sub refresh_all {
    $start_time = time;

    my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) = localtime();
    my $month = sprintf("%d%02d",$year+1900,$mon+1);
    &batch_mode("logs/$month/refresh");

    my $now = localtime();
    print "[Refresh All Devices]  Started at $now. \n";
    &load_old_devices;
    &topo_load_file;

    my $timeout = $CONFIG{timeout};

    foreach my $dev (keys %$OldDevices){
        eval {
            alarm($timeout);
            discover($dev);
            alarm(0); 
        };

        if ($@ =~ /timeout/){
            $TimedOut{$dev}++;
            print "\n  ! Device Timed out ($timeout sec)\n";
        }
    }

    sql_vacuum('device','print'=>1);
    sql_vacuum('device_port','print'=>1);
    sql_vacuum('device_ip','print'=>1);
    &end;

}

=item run() 

Event loop that calls discover() as long as the @Discover_Queue has something in it.

=cut
sub run {
    my $root_device = shift;
    
    my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) = localtime();
    my $month = sprintf("%d%02d",$year+1900,$mon+1);
    &batch_mode("discover/$month/discover_net",1);

    print "Network discovery starting from root $root_device at " . localtime() . "\n";

    my $root_dev_ip = &getip($root_device);
    unless (defined $root_dev_ip){
        print "Cannot resolve $root_device to an IP address.\n";
        return;
    }

    # Getting old devices for statistics.
    &load_old_devices;
    topo_load_file();

    $start_time = time;
    push (@Discover_Queue, $root_dev_ip);

    my $timeout = $CONFIG{timeout};

    
    while (my $this_dev = shift @Discover_Queue){ 
        # We've already been here.
        next if defined $Discovered{$this_dev};
        next if defined $Discovered_Alias{$this_dev};

        # We couldn't connect already, dont try again.
        next if defined $UnDiscovered{$this_dev};

        # New Only scan, ignore existing devices
        #   except let us rediscover our target
        next if ( ((defined $OldDevices->{$this_dev} or defined $Aliases->{$this_dev}) and $New_Only)
                  and ($this_dev ne $root_dev_ip)                                               
                );

        # Set time out 
        eval {
            alarm($timeout);
            discover($this_dev);
            alarm(0);   # Cancel alarm if we return in time.
        };

        if ($@ =~ /timeout/){
            $TimedOut{$this_dev}++;
            print "\n  ! Device Timed out ($timeout sec)\n";
        }
    }
    
    print "Network Discovery complete.\n";
    
    sql_vacuum('device','print'=>1);
    sql_vacuum('device_port','print'=>1);
    sql_vacuum('device_ip','print'=>1);

    &end;
    
}

=item schlop(file,topo_only_flag) 

Used to start a discovery based on topography file.  Will then proceed to do an initial mac_suck() and arp_nip() unless the topo_only_flag is set.

=cut
sub schlop {
    my ($file,$topo_only) = @_;
    &batch_mode('discover_file');

    $start_time = time; 
    print "Discovering devices from file:$file... ";

    &topo_load_file($file);
    &load_old_devices;

    # Add devices
    foreach my $dev (keys %DeviceTopo){
        next if ($New_Only and defined $OldDevices->{$dev});
        last if defined $topo_only and $topo_only;

        my $timeout = defined $CONFIG{timeout} ? $CONFIG{timeout} : 90;

        eval {
            alarm($timeout);
            discover($dev);
            alarm(0);   # Cancel alarm if we return in time.
        };

        if ($@ =~ /timeout/){
            $TimedOut{$dev}++;
            print "\n  ! Device Timed out ($timeout sec)\n";
        }
    }
    
    # Deal with topology info
    foreach my $dev (keys %DeviceTopo){
        topo_add_link($DeviceTopo{$dev}); 
    }

    return if (defined $topo_only and $topo_only);

    # ArpNip and Macsuck newly found devices.
    &load_old_devices;
    &mac_getportmacs;

    foreach my $dev (keys %DeviceTopo){
        my $layers = $OldDevices->{$dev};
        unless (defined $layers and length($layers)){
            print "  Device $dev not discovered. Skipped.\n";
            next;
        }

        macsuck($dev) if (has_layer($layers,2));
        arpnip($dev)  if (has_layer($layers,3));
    }

    foreach my $dev (@Discover_Queue){
        next if (defined $OldDevices->{$dev} or defined $Aliases->{$dev});
        print "  Found new device: $dev\n";
    }
    &end;
}

=item topo_add_link([{},{}])

Pass reference to array of hash references holding link: lines from 
manual topology info.  Adds information to device_port table.

=cut
sub topo_add_link {
    my $links = shift;

    foreach my $link (@$links){
        next unless defined $link;

        unless ( defined $link->{from} and 
                 defined $link->{from_port} and
                 defined $link->{to} and
                 defined $link->{to_port} ) {
            print "  topo_add_link() - Bad link! ", join(',',each %$link), "\n";
            next;
        }
            
        # Add link info
        print "  topo_add_link() $link->{from} / $link->{from_port} --> $link->{to} / $link->{to_port}\n" if $DEBUG;

        # Check for existing / conflicting topology info
        my $link_from = sql_hash('device_port', 
                            ['remote_ip','remote_port'],
                            { 'ip' => $link->{from}, 'port' => $link->{from_port} }
                            );
        my $link_to = sql_hash('device_port', 
                            ['remote_ip','remote_port'],
                            { 'ip' => $link->{to}, 'port' => $link->{to_port}  }
                            );

        # Check for destinations
        unless (defined $link_from) {
            print "    !topo_add_link() -  Topology file error! Source Port Doesn't exist in this link : $link->{from} / $link->{from_port} --> $link->{to} / $link->{to_port} \n";
            next;
        }
        # Check for destinations
        unless (defined $link_to) {
            print "    !topo_add_link() -  Topology file error! Destination Port Doesn't exist in this link : $link->{from} / $link->{from_port} --> $link->{to} / $link->{to_port} \n";
            next;
        }

        # See if from -> to direction conflicts
        if ((defined $link_from->{remote_ip} and $link_from->{remote_ip} ne $link->{to})
          or(defined $link_from->{remote_port} and $link_from->{remote_port} ne $link->{to_port})) {
            print "    !topo_add_link() - $link->{from} / $link->{from_port} has discovered neighbor ",
                  "$link_from->{remote_ip} / $link_from->{remote_port} which conflicts with ",
                  "forced info of $link->{to} / $link->{to_port} \n";
        }

        # See if to -> from direction conflicts
        if ((defined $link_to->{remote_ip} and $link_to->{remote_ip} ne $link->{from})
          or(defined $link_to->{remote_port} and $link_to->{remote_port} ne $link->{from_port})) {
            print "    !topo_add_link() - $link->{to} / $link->{to_port} has discovered neighbor ",
                  "$link_to->{remote_ip} / $link_to->{remote_port} which conflicts with ",
                  "forced info of $link->{from} / $link->{from_port} \n";
        }

        my $rv = insert_or_update('device_port', 
                        {'ip' => $link->{from}, 'port' => $link->{from_port} },
                        {'remote_ip' => $link->{to}, 'remote_port' => $link->{to_port} }
                        );
        print "    topo_add_link() - Failed to add $link->{from} / $link->{from_port} --> $link->{to} / $link->{to_port} \n" if $rv;
    }
}

=item topo_load_file(filename) 

Loads and parses manual topography file. 

=cut
sub topo_load_file {
    my $file = shift;

    $file = "$CONFIG{home}/$CONFIG{topofile}" unless $file;

    my $dev;    # current config line

    print "Loading topology information from $file\n" if $DEBUG;
    open (DEVS,"<$file") or die "topo_load_file($file)  $!\n";
    while (my $line = (<DEVS>)){
        chomp $line;
        # comments
        $line =~ s/#.*//;
        # White Space
        $line =~ s/^\s+//g;
        $line =~ s/\s+$//g;
        next if $line =~ /^\s*$/;
        
        if ($line =~ /^link:(.*)/){
            my ($from_port,$to,$to_port) = split(/,/,$1);

            unless (defined $dev){
                print "Skipping $line. No dev defined.\n" if $DEBUG;
                next;
            }
            #print "    $dev $from_port $to $to_port \n" if $DEBUG;

            my $to_ip = &getip($to);
            $to_ip = &root_device($to_ip);
            unless (defined $to_ip and length $to_ip){
                print "    Can't resolve $to in $line!\n";
                next;
            }
        
            # Save Link info both directions
            push (@{$DeviceTopo{$dev}},   {'from' => $dev,  'from_port' => $from_port, 'to' => $to_ip, 'to_port' => $to_port});
            push (@{$DeviceTopo{$to_ip}}, {'from' => $to_ip,'from_port' => $to_port,   'to' => $dev,   'to_port' => $from_port});

        } elsif ($line =~ /^alias:(.*)/){
            unless (defined $dev){
                print "Skipping $line. No dev defined.\n" if $DEBUG;
                next;
            }
            print "  Alias : $1 found.\n" if $DEBUG;
            next;

        } else {
            $dev = &getip($line);
            $dev = &root_device($dev);
            unless (defined $dev and length $dev){
                print "Bad line or device IP not found in $file : $line\n";
                next;
        }

            else {
                #print "    $line ($dev)\n" if $DEBUG;
            }
            $DeviceTopo{$dev} = [] unless defined $DeviceTopo{$dev};
        }
    }
    close (DEVS);

    print scalar(keys(%DeviceTopo)) . " entries loaded \n" if $DEBUG;

}

=back

=head2 Utility Functions

=over

=item add_user()

Takes 4 optional arguments from @ARGV = (user,pw,port,admin) 

If all 4 are not there, then interactive mode is entered and prompts are given.

=cut
sub add_user {
    my ($user, $pw, $port, $admin) = @ARGV;

    my %args;
    unless (defined $user){
        print "Enter User Name : ";
        $user = <STDIN>;
        chomp $user;
    }

    unless ($user){
        print "User Name is required.\n";
        return;
    }

    unless (defined $pw){
        print "Enter new password for $user [no change]: ";
        $pw = <STDIN>;
        chomp $pw;
        $args{pw} = $pw if $pw;
    }
    unless (defined $port){
        print "Give $user Port Control [no change]? ";
        $port = <STDIN>;
        chomp $port;
        $args{port} = $port if $port;
    }
    unless (defined $admin){
        print "Give $user Admin Rights [no change]? ";
        $admin = <STDIN>;
        chomp $admin;
        $args{admin} = $admin if $admin;
    }

    print "$user $pw $port $admin\n" if $DEBUG;

    my $rv = user_add($user,%args);

    if ($rv) { 
        print "$rv\n";
    }  else {
        print "Added / Changed user $user\n";
    }
}

=item batch_mode(name,time_too?)

Redirects STDOUT to a log file with timestamp.

Can be called recursively.  call batch_mode_end() to return to previous Output.

=cut
sub batch_mode{
    return unless $BatchMode;

    my ($file_name,$want_time,$no_header) = @_;

    my $file_path = $CONFIG{datadir} || 'data';
    my $home      = $CONFIG{home} || '/usr/local/netdisco';
    $file_path    = "$home/$file_path";

    my $extension = defined $CONFIG{logextension} ? $CONFIG{logextension} : 'log';
    
    my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) = localtime();

    # YYYYMMDD-HHmm
    my $date = sprintf("%d%02d%02d",$year+1900,$mon+1,$mday);
    my $time = sprintf("%02d:%02d",$hour,$min);

    my $timestamp = (defined $want_time and $want_time) ? "$date-$time" : $date;
    
    my $file = "$file_path/$file_name-$timestamp.$extension";

    # Path is everything up to the last /
    my $path = $file;
    $path =~ s/\/[^\/]+$//;

    # Make the target directory if not already there
    unless (-d $path){
        system("mkdir -m 0775 -p $path") and die "Can't make directory $path. $!\n";
    }

    my $fh = new IO::File;
    my $old_umask = umask(0000);
    $fh->open($file,O_WRONLY|O_CREAT,0664) or die "Can't open $file. $!\n";
    umask($old_umask);
    
    # Redirect output to log
    push (@OldSTDOUT, select($fh) );
    push (@LogFH,$fh);
    push (@LogFile,$file);

    # No Buffering output
    $| = 1;

    print STDERR "Batch Mode - Output in $file\n" if $DEBUG;
    &header unless (defined $no_header and $no_header);
}

=item batch_mode_end(no_compress_flag)

Returns control of stdout to previous value, optionally compresses 
the finished output file.

Function returns file name of closed output file.

Pass something as first parameter to force no compression.

=cut
sub batch_mode_end {
    my $no_compress = shift;
    return unless $BatchMode;

    return unless scalar @LogFile;

    my $file = pop @LogFile;
    select (pop @OldSTDOUT);
    my $fh = pop @LogFH;
    $fh->close() or die "Can't write $file. $!\n";

    if (defined $CONFIG{compresslogs} and $CONFIG{compresslogs} and ! defined $no_compress){
       print STDERR "\tCompressing $file\n" if $DEBUG;
       my $compress = defined $CONFIG{compress} ? $CONFIG{compress} : "/usr/bin/gzip -f";
       system("$compress $file") and warn "Compress of $file Failed.\n";
    }
    
    return $file;
}

=item end_int_handler 

=cut
sub end_int_handler {
    &end;
    &batch_mode_end;
    exit;
}

=item end()

Cleanup routine that is called upon interrupt (ctrl-c) or end of routines. 

Prints various statistics to stdout or batch_redirect() and calls Netdisco::log().

=cut
sub end {
    return unless $start_time != 0;

    $end_time = time;
    my $run_time = sprintf("%-.2f",($end_time-$start_time)/60);
    print "\n" .'-'x70 . "\n";
    print "Run took $run_time minutes\n";

    if ($ArpTotal > 0 ){
        print "Found $ArpTotal arp cache entries.\n";
        log('arp',"$ArpTotal entries. $run_time minutes.") if $Log;
    }

    if (defined $NbtTotal){
        my $nodes = scalar(keys(%$OldNodes));
        my $pct   = sprintf("%2.2f",($NbtTotal/$nodes)*100);
        print "Found $NbtTotal/$nodes ($pct\%) nodes with NetBIOS entries.\n";
        log('netbios',"$NbtTotal entries. $run_time minutes.") if $Log;
    }
    
    my $mac_seen = scalar keys(%MacSeen);
    if ($mac_seen){
        
        print "Saw $mac_seen distinct nodes in $MacTotal forwarding table entries.\n";
        log('mac',"$mac_seen distinct nodes.  $MacTotal forwarding table entries.  $run_time minutes.") if $Log;
    }

    my $discover_count = scalar(keys(%Discovered));
    if ($discover_count){
        print "Discovered $discover_count devices.\n";

        # Check for new/old devices
        my $new = 0;
        my $old = scalar keys %$OldDevices;

        foreach my $device (keys %Discovered){
            $new++ unless defined $OldDevices->{$device};
        }

        foreach my $device (keys %$OldDevices){
            $old-- if defined $Discovered{$device};
        }

        print "Discovered : $new new devices.  Missed: $old old devices.\n";

        log('discover',"$discover_count devices. ($new new) ($old old) $run_time minutes.") 
            if $Log;

        if (scalar keys %NoCDP){
            print "Devices Found by CDP but without CDP info avail. via SNMP :\n";
            foreach my $dev (keys %NoCDP){
                print "    $dev\n";
            } 
            log('nocdp',join(' ',keys %NoCDP)) if $Log;
        }
        
        if (scalar keys %UnDiscovered) {
            print "Devices Found by CDP but not reachable by SNMP : \n";
            foreach my $dev (keys %UnDiscovered){
                print "    $dev\n";
            } 
            log('nosnmp',join(' ',keys %UnDiscovered)) if $Log;
        }

        if (scalar keys %TimedOut){
            print "Devices timed out : \n";
            foreach my $dev (keys %TimedOut){
                print "    $dev\n";
            }
            log('timeout',join(' ',keys %TimedOut)) if $Log;
        }
    }
    &batch_mode_end;
    if ($DaemonMode){
        return;
    }
    exit;
}

=item load_old_devices()

Populates %Old_Devices with which devices are in the database.

=cut
sub load_old_devices {
    print "load_old_devices()\n" if $DEBUG;
    $OldDevices = sql_column('device',['ip','layers']);
    $Aliases = sql_column('device_ip',['alias','ip']);
}

=item load_old_nodes(days)

Populates %Old_Nodes with which nodes are in the database.

Nodes will have to have been seen in the last DAYS days.

=cut
sub load_old_nodes {
    my $days = shift;
    print "load_old_nodes()\n" if $DEBUG;
    my $where = {active=>1, 
        'mac'=>\\"in (select mac from node where active)" };
    if (defined $days){
        $where->{'age(time_last)'}=\\"<= interval '$days day'"; 
    }
    my $old_nodes = sql_rows('node_ip',['ip'],$where);
    foreach my $n (@$old_nodes){
        my $ip = $n->{ip};
        $OldNodes->{$ip}++;
    }
}

=item parse_oui()

Parses file oui.txt in current directory.  Uses contents to stuff
table "oui".

=cut
sub parse_oui {
    print "parse_oui()\n";
    my $oui_file = "$CONFIG{home}/oui.txt";
    unless (-r $oui_file){
        print "  $oui_file not found!\n";
        die "Please run ''make oui'' to download oui.txt.  Or read INSTALL\n";
    }
    print "Removing old contents of oui table in database.\n";
    sql_do(qq/DELETE FROM oui WHERE true/);
    print "Schlopping contents of oui.txt to database.\n";
    my %OUI;
    open (OUI, "<$oui_file") or die "Can't open OUI. $!\n";
    while (my $line = <OUI>){
        chomp $line;
        if ($line =~ /^(.{2}-.{2}-.{2})\s+\(hex\)\s+(.*)\s*$/i){
            $OUI{$1}=$2;
        } 
    }
    close (OUI);

    my $oui_count = 0;
    foreach my $oui (keys %OUI){
        my $company = $OUI{$oui};
        # make 00-00-00 into 00:00:00
        $oui =~ s/-/:/g;
        print "$oui : $company\n" if $DEBUG;
        insert_or_update('oui',{},{'oui' => $oui, 'company' => $company } );
        $oui_count++;
    }
    print "Added $oui_count entries from oui.txt\n";
    print "Cleaning up Database table OUI.\n";
    sql_vacuum('oui',full=>1,verbose=>1,'print'=>1);
}

=item timeout()

Signal handler for SIGALARM

=cut
sub timeout {
    die "timeout";
}

=back

=head2 SNMP Functions

=over

=item arpnip() 

Connects to device and reads its ARP cache. Then adds entries to C<node_ip> table. 

Cheers to Jim Warner for the original arpnip.

=cut
sub arpnip {
    my $hostname = shift;

    my $ip = getip($hostname);

    print "arpnip($hostname) : ";

    unless (defined $ip){
        print " Name does not resolve with DNS.\n";
        return;
    }

    if (in_subnets($ip,'arpnip_no')) {
        print " Excluded from arpnipping in config file.\n";
        return;
    }

    &mac_getportmacs unless defined $PortMAC;

    my $dev = sql_hash('device',['*'],{'ip'=>$ip});

    unless (defined $dev->{ip}) { 
        print "  Device not found in database.  Try ``netdisco -N -r $hostname''\n";
        return;
    }

    print "\n";

    my $device = get_device($hostname) or return;

    # Fetch ARP Cache
    my $at_paddr = $device->at_paddr();
    my $at_netaddr = $device->at_netaddr();

    my $arp_count =0;
    foreach my $arp (keys %$at_paddr){
        my $mac = $at_paddr->{$arp};
        my $ip = $at_netaddr->{$arp};

        next unless defined $ip;

        # BayRS routers report incomplete MAC addresses for frame relay DLCI
        # interfaces.  Include this check for this case plus any others.
        unless (&is_mac($mac)) {
            print " $mac malformed ... skipping\n" if $DEBUG;
            next;
        }
        # Skip network broadcast addresses.  Some devices use this and then the
        # broadcast IP will show up in the node table.
        next if uc($mac) eq 'FF:FF:FF:FF:FF:FF';
        
        # Skip Passport 8600 CLIP MAC addresses, they will be used as root IP if
        # present so the IP will be identified.  Do not let the bogus MAC make
        # them show up in the node table.
        next if uc($mac) eq '00:00:00:00:00:01';
    
        # Skip VRRP addresses - don't want them showing up as nodes.  Don't know
        # what else to do with these right now.  What about HSRP IP's?
        if ($mac =~ /^00:00:5e:00:/i) {
            print " $mac is a VRRP address ... skipping\n" if $DEBUG;
            next;
        }

        if (defined $PortMAC->{$mac}) {
            print "  $mac is a port on device $PortMAC->{$mac} ... skipping\n"
                if $DEBUG;
            next;
        }   

        print "  $ip : $mac\n" if $DEBUG;
        add_arp($mac,$ip);
        $arp_count++;
    }
    print "  Processed $arp_count ARP Cache entries.\n";
    $ArpTotal += $arp_count;
    
    insert_or_update('device',{'ip'=> $dev->{ip} },{'last_arpnip'=> scalar localtime});

    # Fetch Subnets - Feature not implemented yet.
    #get_subnets($device);
}

=item arpwalk() 

Visits every Layer 3 device and trys to get its ARP Cache.  

Calls arpnip() for each device.  

=cut
sub arpwalk {
    $start_time = time;
    
    my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) = localtime();
    my $month = sprintf("%d%02d",$year+1900,$mon+1);
    &batch_mode("logs/$month/arp",1);
    print "Grabbing Arp Cache from all layer 3 devices (". localtime() . ")...\n";

    # Get our old devices, IP->Layer mapping
    &load_old_devices;

    # Grab existing mac addresses for switch ports
    &mac_getportmacs;

    foreach my $device (keys %$OldDevices){
        my $has_3 = has_layer($OldDevices->{$device},3);
        arpnip($device) if ($has_3);
    }

    sql_vacuum('node_ip','print'=>1);

    &end;
}

=item  create_device(host,snmp_community[,snmp_version,snmp::info subclass]) 

Connect to a device via SNMP::Info with a given host and community string.

If an optional version and subclass are given, no device type discovery is done.

If a more specific device type is not found  (is probably not a network device) then -1 is returned.

=cut
sub create_device {
    my ($hostname,$community,$version,$objtype) = @_;

    my $ver     = $version || $CONFIG{snmpver} || 2;
    my $retries = $CONFIG{snmpretries} || 2;  
    my $class   = $objtype || 'SNMP::Info';
    my $autospecify = defined $objtype ? 0 : 1;
   
    my $print_comm = $community;
    # If it's vlan, do last letter @ vlan
    if ($print_comm =~ /\@/){
        $print_comm =~ s/^.*(.\@\d+)$/$1/;  # VLAN Comm
    } else {
        # else do last letter
        $print_comm = substr($print_comm,-1,1);
    }
    printf("  create_device(%s,%s,%d,%s,%d)\n",
           $hostname,$print_comm,$ver, $objtype || 'undef',$retries)
         if $DEBUG;

    # Get Device Info
    my $device = new $class( 
                            'Debug'       => $DEBUG,
                            'AutoSpecify' => $autospecify,
                            'DestHost'    => $hostname,
                            'Community'   => $community,
                            'Version'     => $ver,
                            'Retries'     => $retries,
                            'MibDirs'     => $CONFIG{mibdirs} || [],
                           );
    

    # Test for connectivity
    my $layers = $device->layers() if defined $device;

    # Try Version 1 if we haven't already
    #   V1 screws up some HP switches that support 2, so we stick w/ 2 first
    if (!defined $device or !defined $layers and $ver != 1){
        
        print " [Trying SNMP Version 1] ";
        printf("create_device(%s,%s,1)\n",$hostname,substr($community,-1,1)) if $DEBUG;
        $device = new $class(
                             'Debug'       => $DEBUG, 
                             'AutoSpecify' => $autospecify,
                             'DestHost'    => $hostname,
                             'Community'   => $community,
                             'Version'     => 1,
                             'Retries'     => $retries,
                             'MibDirs'     => $CONFIG{mibdirs} || [],
                            );
    }
    
    unless (defined $device) {
        $DEBUG and print "  Can't connect to $hostname\n";
        return undef;
    }

    $class = $device->class();
    if (!defined $device or !defined $class){
        $DEBUG and print "  Could not connect to $hostname.\n";
        return undef;
    }
        
    if ($class eq 'SNMP::Info'){
        my $layers = $device->layers();
        print "  Device Talks SNMP but only has layers $layers.  Skipping\n";
        return -1;
    }

    $DEBUG and print "  Device Type : $class \n";

    # Tag on some netdisco specific info to the SNMP::Info object.
    $device->{ip}        = &getip($hostname);
    $device->{dns}       = &hostname($device->{ip});

    return $device;
}

=item device_root() 

Looks to see if the device has a master IP instead of the one given.  
Checks for root_ip() method, then tries to lookup the reverse entry for sysName.0

=cut
sub device_root {
    my $device = shift;
    
    my $foundip = $device->{ip};

    # use the device override
    my $root_ip = $device->root_ip();
    return $root_ip if (defined $root_ip and length($root_ip));


    # Check the reverse of sysName.0 and use it for our real_ip?
    if (defined $CONFIG{reverse_sysname} and $CONFIG{reverse_sysname} ){
        my $name   = $device->name();
        my $nameip = &getip($name);

        print "  device_root(sysName.0 IP: $nameip Found IP:$foundip\n" if $DEBUG;
        return $nameip if (defined $nameip and length($nameip));
    }
    
    return $foundip;
}

=item find_neighbors() 

Finds all the CDP information on the device and stores the results in device_node.  

Adds to the @Discover_Queue

=cut
sub find_neighbors {
    my $device = shift;
   
    print "  Fetching Neighbor Information  : ";

    my $ip = $device->{ip};
    my $c_ip       = $device->c_ip();

    unless ($device->hasCDP() or scalar keys %$c_ip){
        # Great, catalyst 2926 doesnt give us cdpRun
        $NoCDP{$ip}++;    
        print "! CDP not Enabled.\n";
        return;
    }

    my $c_if       = $device->c_if();
    my $c_port     = $device->c_port();
    my $c_id       = $device->c_id();
    my $c_platform = $device->c_platform();
    my $interfaces = $device->interfaces();

    foreach my $key (keys %$c_ip){
        print '.';
        # Get our port to iid mapping
        my $iid = $c_if->{$key};
        my $port = $interfaces->{$iid};

        unless (defined $port){
           print "find_neighbors($ip) - Port for IID:$iid not resolved.\n";
           next;
        }

        my $remote_ip   = $c_ip->{$key};
        my $remote_port = undef;
        my $remote_type = $c_platform->{$key};
        my $remote_id   = $c_id->{$key};

        # Hack for BAY devices where if a BAY device is connected to a
        # non-bay device, we 'hear' other devices on the other end of this
        # port, but we don't know who we're talking to.
        # Therefore, set a loop back to ourselfs as a place marker, but add
        # our found nodes to the discovery queue.
        if (ref $remote_ip eq 'ARRAY'){
            $DEBUG and print "  Port:$port sees multiple neighbors. Setting loopback.\n";
            # Discover neighbors
            foreach my $neighbor (@$remote_ip){
                unless (defined $Discovered{$neighbor}) {
                    $DEBUG and print "  Adding $neighbor to discovery queue.\n";
                    push (@Discover_Queue, $neighbor);
                }
            }
            # Set loopback
            $remote_ip   = $ip;
            $remote_port = $port;

        } else {
            $remote_port = $c_port->{$key};

            if (defined $remote_port) {
                # get rid of any weird characters
                $remote_port =~ s/[^\d\/\.,()\w:]+//gi;

                # Swap catalyst remote port as 2/1 to 2.1
                $remote_port =~ s/\//\./ if ($remote_port =~ /^\d+\/\d+$/);
            } else {
                print "  No remote_port found for Port:$port connected to $remote_ip.\n";
            }
        }

        next unless (defined $remote_ip and length($remote_ip));

        # IP Phone Detection -- Add known phone models in parens.
        if (defined $remote_type and $remote_type =~ /(mitel.5\d{3})/i) {
            $remote_type = 'IP Phone - '.$remote_type if $remote_type !~ /ip phone/i; 
        }

        my $port_exists = sql_scalar('device_port',['true'],{'ip'=>$ip,'port'=>$port});
        unless (defined $port_exists and $port_exists){
            print "  Port $port not in DB -> $remote_ip/$remote_port.\n";
            next;
        }

        my %store;
        $store{'remote_ip'}   = $remote_ip;
        $store{'remote_port'} = $remote_port;
        $store{'remote_type'} = $remote_type;
        $store{'remote_id'}   = $remote_id;
       
        insert_or_update('device_port', {'ip' => $ip , 'port' => $port },
                        \%store);

        unless (defined $Discovered{$remote_ip}) {
            $DEBUG and print "  Adding $remote_ip to discovery queue.\n";
            push (@Discover_Queue, $remote_ip);
        }
    }
    print "\n";
}

=item get_device(host)

Calls create_device() with a community string

If cached values are stored in the database for the SNMP version and community strings,
they are used. 

If no cached values are available, or if they fail, then the values from the config file are
tried.

=cut
sub get_device {
    my $hostname = shift;
    my $device   = undef;
    my $comm     = undef;

    print "  get_device($hostname)\n" if $DEBUG;

    # Check to see if device is in database
    my $ip       = &getip($hostname);
    my $dev_ip   = &root_device($ip);

    # Warn if we are using an alias
    if (defined $dev_ip and $dev_ip ne $ip){
        print "!  $ip is an alias of $dev_ip.\n";
        $dev_ip = undef;
    }

    # Call with stored comm/ver unless supplied $ver
    if (defined $dev_ip) { 
        my $row     = sql_hash('device',['snmp_ver','snmp_comm'],{'ip'=>$dev_ip});
        my $version = $row->{snmp_ver};
           $comm    = $row->{snmp_comm};

        printf("  get_device(%s) - Connecting using cached info: %s/%s/%s\n",$hostname,$dev_ip,substr($comm,-1,1),$version)
            if $DEBUG;
        $device = create_device($dev_ip,$comm,$version);

        print "!  Could not connect to $dev_ip with SNMP community and version info in database.\n"
            unless defined $device;
    }

    # Stored community not available, or didn't work. 
    if (!defined $device){
        # Try each community string
        foreach my $config_comm (@{$CONFIG{community}}) {

            # Don't bother retrying the failed one.
            next if (defined $comm and ($config_comm eq $comm));

            $device = create_device($hostname,$config_comm);

            if (defined $device and $device == -1){
                $device = undef;
                last;
            } elsif (defined $device){
                last;
            }
        }
    }
    unless (defined $device) {
        $UnDiscovered{$ip}++ if defined $ip;
        print "! Device Not Supported or I can't connect to it via SNMP.\n";
        return undef;
    }
    return $device;
}

=item get_subnets(device)

This feature not yet implemented.

=cut
sub get_subnets {
    my $device = shift;
    my $nets = $CONFIG{networks};
    return unless defined $nets;
    foreach my $net (split(/\s*,\s*/,$nets)){
        # TODO - Parse nets with their bitmask
        my $subnets = $device->ipr_mask($net);
        foreach my $route (sort {sort_ip} keys %$subnets){
            my $mask = mask_to_bits($subnets->{$route});
            next if $mask == 32;
            # TODO - Compare with net given above
            print "$route/$mask\n";
        }
    }  
}

=item get_vlan(host,vlan number,community,snmp ver,snmp::info object type) 

Calls create_device() for a given VLAN using the modified community string.

=cut
sub get_vlan {
    my ($hostname,$vlan,$community,$version,$objtype) = @_;

    my $device = undef;
    $community .= '@'.$vlan; 
    
    return create_device($hostname,$community,$version,$objtype);
}

=item mac_getportmacs() 

Fills the global %PortMAC with MAC addresses of ports already discovered.  
This is to make sure we don't mac-suck existing ports, such as VLANs.

=cut
sub mac_getportmacs {
    print "mac_getportmacs() ..." if $DEBUG;
    
    # I probably could have done this in a join but ...

    my $portmacs = sql_rows('device_port',['mac','ip'],{'mac' => \\'is not null'}); 
    foreach my $row (@$portmacs){
        my $mac = $row->{mac};
        my $ip  = $row->{ip};
        $PortMAC->{$mac}=$ip;
    }
    my $devmacs = sql_rows('device',['mac','ip'],{'mac' => \\'is not null'});
    foreach my $row (@$devmacs){
        my $mac = $row->{mac};
        my $ip  = $row->{ip};
        $PortMAC->{$mac}=$ip;
    }

    print " found ",scalar(keys %$PortMAC), " MACs.\n" if $DEBUG;
}

=item macsuck() 

Walks forwarding table for a specific device. 
Gets mac addresses that are listed in physical ports that do not 
have a neighbor listed.   If the device has VLANs, it will walk each
VLAN and get the MAC addresses from there.

=cut
sub macsuck{
    my $hostname = shift;

    my $ip = getip($hostname);

    print "macsuck($hostname) : ";

    unless (defined $ip){
        print " Name does not resolve with DNS.\n";
        return;
    }

    if (in_subnets($ip,'macsuck_no')) {
        print " Excluded from macsucking in config file.\n";
        return;
    }

    # Get the device info and its interfaces
    my $dev = sql_hash('device',['*'],{'ip'=>$ip});
    my $ports = sql_rows('device_port',['*'],
        {'ip'=>$ip});

    unless (defined $dev->{ip}) { 
        print "\n  Device not found in database.  Try ``netdisco -N -r $hostname''\n";
        return;
    }

    &load_old_devices unless (defined $OldDevices);
    &mac_getportmacs  unless (defined $PortMAC);

    # Move the ports from an array to a hash, indexed on port name
    my %dbports = ();
    foreach my $p (@$ports) {
        my $port = $p->{port};
        $dbports{$port}=$p;
    }

    # Make the SNMP connection
    my $time1 = time;
    my $device = get_device($hostname) or return;
    my $entries1 = $MacTotal;

    my $interfaces = $device->interfaces();

    walk_fwtable($device,\%dbports,$interfaces);

    # For certain Cisco switches you have to connect to each
    # VLAN and get the forwarding table out of it.
    #   Notably the Catalyst 5k, 6k, and 3500 series
    my $cisco_comm_indexing = $device->cisco_comm_indexing() || 0;
    if ($cisco_comm_indexing){
        print " Device supports Cisco commuinty string indexing. Connecting to each VLAN:\n";
        my $v_name = $device->v_name() || {};
        my $i_vlan = $device->i_vlan() || {};
        my $ver    = $device->snmp_ver();
        my $comm   = $device->snmp_comm();
        my $obj    = $device->class();

        # Get list of VLANs currently in use by ports
        my %vlans;
        foreach my $key (keys %$i_vlan){
            my $vlan = $i_vlan->{$key};
            $vlans{$vlan}++;
        }
    
        # For each VLAN, connect and then macsuck
        foreach my $vid (sort { my $aa=$a; my $bb=$b; $aa=~ s/^\d+\.//;$bb=~ s/^\d+\.//;
                                # Sort by VLAN id
                                $aa <=> $bb
                              }
                         keys %$v_name)
        {

            my $vlan_name = $v_name->{$vid} || '(Unnamed)';
            # VLAN id comes as 1.142 instead of 142
            my $vlan = $vid;
            $vlan =~ s/^\d+\.//;

            if (defined $CONFIG{macsuck_no_vlan} and defined $CONFIG{macsuck_no_vlan}->{$vlan_name}){
                print " VLAN:$vlan_name ($vlan) Skipped by configuration file.\n";
                next;
            }

            # Only macsuck VLAN if in use by port
            #   but check to see if device serves us that list first
            if (scalar keys(%$i_vlan) and !defined $vlans{$vlan}
                and !$CONFIG{macsuck_all_vlans}){
                print " VLAN:$vlan_name ($vlan) Skipped because not in use by a port.\n";
                next;
            }

            print " VLAN:$vlan_name ($vlan) : ";

            # feeding all the connect info as a speedup, instead of
            #   retrying all the versions and communities
            my $vlan_device = get_vlan($hostname,$vlan,$comm,$ver,$obj);
            unless (defined $vlan_device){
                print "!\n";
                next;
            }
            walk_fwtable($vlan_device,\%dbports,$interfaces);

        }
    }

    # Log This
    my $entries2 = $MacTotal;
    my $now = localtime;  my $time2 = time;
    insert_or_update('device',{'ip'=> $ip},{'last_macsuck'=>$now});
    print " Saw : ",$entries2-$entries1, " forwarding table entries.  Took ",$time2-$time1," seconds.\n" if $DEBUG;

}

=item macwalk() 

Grabs all the devices out of the database. 
Runs macsuck() on each device that has layer2 capabilites.

=cut
sub macwalk {
    $start_time = time;
    my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) = localtime();
    my $month = sprintf("%d%02d",$year+1900,$mon+1);
    &batch_mode("logs/$month/mac",1);
    print "Grabbing Mac Addresses from all Layer 2 Devices (" . localtime() . ")...\n";

    # Get our old devices, IP->Layer mapping
    &load_old_devices;
    
    # Get mac addresses of all the ports 
    &mac_getportmacs;

    my $timeout = $CONFIG{macsuck_timeout} || 90;
    foreach my $device (keys %$OldDevices){
        my $has_2 = has_layer($OldDevices->{$device},2);
        next unless $has_2;
        eval {
            alarm($timeout);
            macsuck($device);
            alarm(0);
        };

        if ($@ =~ /timeout/){
            $TimedOut{$device}++;
            print "\n  ! Device $device timed out in macsuck() ($timeout sec)\n";
        }
    }
    sql_vacuum('node','print'=>1);

    &end;
}

=item port_control(switch,port,direction)

=cut
sub port_control {
    my ($switch,$port,$direction,$job) = @_;

    unless (defined $switch and defined $port and defined $direction){
        print "Usage : port_control(switch,port,up/down)\n";
        return undef;
    }
    unless (defined $CONFIG{community_rw} and scalar @{$CONFIG{community_rw}}){
        print "No read-write community string has been set. Please add a community_rw setting to the Config file.\n";
        return undef;
    } 

    # Check for device in DB
    my $ip = getip($switch);
    $ip    = root_device($ip);

    # Get dev info from database
    my $db_dev = sql_hash('device',['*'],{'ip' => $ip}) if defined $ip;

    unless (defined $ip and defined $db_dev){
        print "Device $switch not found in netdisco.  Please discover device and try again.\n";
        return undef;
    } 
    
    # Check for port
    my $db_port = sql_hash('device_port',['*'],{ 'ip'=>$ip, 'port'=>$port });

    # Categorize this port
    my $is_phone      = (defined $db_port->{remote_type} and $db_port->{remote_type} =~ /ip.phone/i) ? 1 : 0;
    my $is_vlan       = (defined $db_port->{type} and $db_port->{type} =~ /^(53|propVirtual|l2vlan|l3ipvlan|135|136|137)$/i) ? 1 : 0;
       $is_vlan       = $is_vlan || (defined $db_port->{port} and $db_port->{port} =~ /vlan/i);
       $is_vlan       = $is_vlan || (defined $db_port->{name} and $db_port->{name} =~ /vlan/i);
    my $allow_phones  = (defined $CONFIG{portctl_nophones} and $CONFIG{portctl_nophones}) ? 0 : 1;
    my $allow_uplinks = (defined $CONFIG{portctl_uplinks} and $CONFIG{portctl_uplinks}) ? 1 : 0;
    my $allow_vlans   = (defined $CONFIG{portctl_vlans} and $CONFIG{portctl_vlans}) ? 1 : 0;

    unless (defined $db_port){
        print "Port : $port not found in database for device $switch\n";
        return undef;
    }

    # Check if uplink port
    if (defined $db_port->{remote_ip} and !$is_phone and !$allow_uplinks){
        print "Port : $port is an uplink port. Control from netdisco not allowed.\n";
        return undef;
    } 
    
    # Check if Phone
    if ($is_phone and !$allow_phones){
        print "Port : $port has an IP Phone connected to it.  Netdisco configured to not allow its shutoff.\n";
        return undef;
    }

    # Check if is VLAN
    if ($is_vlan and !$allow_vlans){
        print "Port : $port is a VLAN interface.  Netdisco Configured to not allow its shutoff.\n";
        return undef;
    }

    # SNMP connect
    my $device;
    my $snmp_ver = $db_dev->{snmp_ver} || 2;
    foreach my $comm (@{$CONFIG{community_rw}}) {
        $device = create_device($ip,$comm,$snmp_ver);
        last if (defined $device and $device != -1); 
    }

    unless (defined $device){
        print "Could not connect to device with read-write community string.\n";
        return undef; 
    }
    
    my $interfaces = $device->interfaces();
    my %rev_if     = reverse %$interfaces;
    my $iid        = $rev_if{$port};

    # Switch the port
    my $rv = $device->set_i_up_admin(lc($direction),$iid);
    
    unless (defined $rv){
        my $error = $device->error() || '';
        print "Set failed. $error\n";
        return undef;
    }

    # Mark down change in netdisco
    insert_or_update('device_port', {'ip'=>$ip,'port'=>$port} , {'up_admin'=>$direction});

    print "Succesfully set Port:$port $direction on $switch\n";
    return 1;
}

=item port_switch({})

=cut
sub port_switch {
    my $job = shift;

    # Not sent from front-end via admin daemon
    unless (defined $job){
        
    }
    my $user   = $job->{username};
    my $userip = $job->{userip};
    my $ip     = getip($job->{device});
    my $port   = $job->{port};
    my ($dir,$reason) = split('-',$job->{subaction});
    my $long_reason = $netdisco::PORT_CONTROL_REASONS{$reason}->[0];
    my $log    = $job->{log};
    my $dns    = &hostname($ip);
   
    print "port_switch() - $user @ $userip.  d:$dir r:$reason i:$ip d:$dns p:$port l:$log\n" if $DEBUG;
    # Switch the Port
    my $rv = port_control($ip,$port,$dir); 

    if (!defined $rv){
        print "\n[FAILED].\n";
        $log = "[FAILED] - See admin queue job log. \n $log";
        return 1;
    }

    my $action = $dir;
    $action = 'enable'  if $dir eq 'up';
    $action = 'disable' if $dir eq 'down';

    # Send E-Mail to Abuse
    my $portctl_email = $CONFIG{portctl_email};
    if (defined $portctl_email){
        print "Sending notification to $portctl_email\n";
        my $body = <<"end_body";
........ n e t d i s c o .........
  Device : $dns ($ip) 
  Port   : $port
  Action : $action
  User   : $user \@ $userip 
  Reason : [$reason] - $long_reason
  Log    : $log

end_body

        &mail($portctl_email,"port $action $dns($ip)/$port",$body);
    }
    # Log
    insert_or_update('device_port_log', {},
                     {'ip'=>$ip,'port'=>$port,'log'=>$log,'userip'=>$userip,
                      'username'=>$user,'action'=>$action, 'reason' => $reason }
                    ); 

    return 0;
}

=item store_device() 

Calls all the global methods and sends the results off to the database

=cut
sub store_device {
    my $device = shift;

    print "\n  Fetching Device Info           : \n";

    # Deal w/ devices with multiple IP address like most routers
    my $foundip = $device->{ip};
    my $devip = device_root($device);
    $device->{ip} = $devip;

    if ($devip ne $foundip) {
        print "  Using $devip instead of $foundip \n" if $DEBUG;

        # Set device name to root, not alias
        my $new_dns = &hostname($devip);
        $device->{dns} = $new_dns if (defined $new_dns and length($new_dns));
    }

    my $ip_index   = $device->ip_index();
    my $interfaces = $device->interfaces();
    
    # Remove all alias IP addresses
    sql_do(qq/DELETE from device_ip where ip = '$devip'/);

    # Store all our IPs
    foreach my $ip (keys %$ip_index){
        next if $ip eq $devip;

        next if $ip eq '0.0.0.0';
        # Local Host
        next if $ip =~ /^127\.0\.0\./;

        if (defined $CONFIG{ignore_private_nets} and $CONFIG{ignore_private_nets}) {
            my $ignore =0;
            # Class A Private
            $ignore++ if $ip =~ /^10\./;
            # Class B Private
            $ignore++ if $ip =~ /^172\.16\./;
            # Class C private
            $ignore++ if $ip =~ /^192\.168\.0\./;
            print "  Ignoring private address $ip\n" if ($ignore and $DEBUG);
            next if $ignore;
        }

        my $iid  = $ip_index->{$ip};
        my $port = $interfaces->{$iid}; 
        my $dns  = &hostname($ip);

        insert_or_update('device_ip', {'ip' => $devip,  'alias' => $ip},
                        {'ip' => $devip , 'alias' => $ip, 'port' => $port,
                         'dns' => $dns }
                        );
        $DEBUG and print "  Adding $ip to device_ip\n";
        $Aliases->{$ip} = $devip;
        
        # Mark alias down
        $device->{_alias}->{$ip}++;
    }

    # VTP Management Domain -- assume only one.
    my $vtpdomains = $device->vtp_d_name();
    my $vtpdomain;
    if (defined $vtpdomains and scalar(values(%$vtpdomains))) {
        $vtpdomain = (values(%$vtpdomains))[-1];
    }

    my %store = ();

    $store{ip}          = $device->{ip};
    $store{dns}         = $device->{dns};
    $store{snmp_ver}    = $device->snmp_ver();
    $store{snmp_comm}   = $device->snmp_comm();
    $store{description} = $device->description();
    $store{uptime}      = $device->uptime();
    $store{contact}     = $device->contact();
    $store{name}        = $device->name();
    $store{location}    = $device->location();
    $store{layers}      = $device->layers();
    $store{ports}       = $device->ports();
    $store{mac}         = $device->mac();
    $store{serial}      = $device->serial();
    $store{model}       = $device->model();
    $store{ps1_type}    = $device->ps1_type();
    $store{ps2_type}    = $device->ps2_type();
    $store{ps1_status}  = $device->ps1_status();
    $store{ps2_status}  = $device->ps2_status();
    $store{fan}         = $device->fan();
    $store{slots}       = $device->slots();
    $store{vendor}      = $device->vendor();
    $store{os}          = $device->os();
    $store{os_ver}      = $device->os_ver();
    $store{vtp_domain}  = $vtpdomain;
    #$store{log}         = $device->log();
    $store{last_discover} = localtime;
    
    insert_or_update('device', {'ip' => $device->{ip} },
                    \%store);
}

=item store_interfaces() 

Gets all the interface information using Table Methods in SNMP::Info.  

Deletes the old interface entries in device_port and puts in new ones.

=cut
sub store_interfaces { 
    my $device = shift;
    
    print "  Fetching Interface Information : ";
    my $ip = $device->{ip};

    # Delete old interface information (for dynamic,vlan...)
    sql_do(qq/DELETE from device_port where ip = '$ip'/);

    my $interfaces     = $device->interfaces();
    my $i_type         = $device->i_type();
    my $i_ignore       = $device->i_ignore();
    my $i_descr        = $device->i_description();
    my $i_mtu          = $device->i_mtu();
    my $i_speed        = $device->i_speed();
    my $i_mac          = $device->i_mac();
    my $i_up           = $device->i_up();
    my $i_up_admin     = $device->i_up_admin();
    my $i_name         = $device->i_name();
    my $i_duplex       = $device->i_duplex();
    my $i_duplex_admin = $device->i_duplex_admin();
    my $i_stp_state    = $device->i_stp_state();
    my $i_vlan         = $device->i_vlan();
    my $i_lastchange   = $device->i_lastchange();

    foreach my $if (keys %$interfaces) {
        print '.';
        my %store = ();
        my $port = $interfaces->{$if};
        unless (defined $port and length($port)) {
            $DEBUG and print "\n  Ignoring $if (no port mapping)\n";
            next;
        }
        $store{type}  = $i_type->{$if};
        if(exists $i_ignore->{$if}) {
            $DEBUG and print "\n  Ignoring $if ($store{type})\n";
            next;
        }
        $store{ip}           = $ip;
        $store{port}         = $port;
        $store{descr}        = $i_descr->{$if};
        $store{up}           = $i_up->{$if};
        $store{up_admin}     = $i_up_admin->{$if};
        $store{mac}          = $i_mac->{$if};
        $store{speed}        = $i_speed->{$if};
        $store{mtu}          = $i_mtu->{$if};
        $store{name}         = $i_name->{$if};
        $store{duplex}       = $i_duplex->{$if};
        $store{duplex_admin} = $i_duplex_admin->{$if};
        $store{stp}          = $i_stp_state->{$if};
        $store{vlan}         = $i_vlan->{$if};
        $store{lastchange}   = $i_lastchange->{$if};

        insert_or_update('device_port', { 'ip' => $ip, 'port' => $store{port} }, 
                         \%store );        

    }
    print "\n";
}

=item walk_fwtable()  

Walks the Forwarding table from the C<BRIDGE-MIB>
for the given device, and then adds MAC addresses to the C<node> table.

=cut
sub walk_fwtable {
    my ($device,$dbports,$interfaces) = @_;

    my $ip = $device->{ip};
    my $fw_mac     = $device->fw_mac();
    my $fw_port    = $device->fw_port();
    my $bp_index   = $device->bp_index();

    # To map the port in the forwarding table to the 
    # physical device port we have this triple indirection:
    #      fw_port -> bp_index -> interfaces
    
    foreach my $fw_index (keys %$fw_mac){    
    #foreach my $fw_index (keys %$fw_port){
        # Convert the 0.254.123.456 index entry to a MAC address.
        my $mac = $fw_mac->{$fw_index};
        #my $mac    = join(':',map {sprintf("%02x",$_)} split(/\./,$fw_index));
        my $bp_id  = $fw_port->{$fw_index};

        $MacTotal++;

        unless (defined $bp_id) {
            print " Port $fw_mac->($fw_index)has no fw_port mapping.  Skipping\n"
            #print "  MAC $mac has no fw_port mapping. Skipping\n"
                if $DEBUG;
            next;
        }

        my $iid    = $bp_index->{$bp_id};

        unless (defined $iid) {
            print "  Port $bp_id has no bp_index mapping. Skipping\n"
                if $DEBUG;
            next;
        }

        my $port  = $interfaces->{$iid};

        unless (defined $port) {
            print "  SNMP iid $iid has no physical port matching. Skipping.\n"
                if $DEBUG;
            next;
        }

        unless (defined $dbports->{$port}){
            print "  Port ($port) is not in database.  Skipped.\n"
                if $DEBUG;
            next;
        }

        # Check to see if the port is connected to another device,
        #   and if we have that device in the DB.  

        #If we dont see the device in the db, but there is a neighbor, then we capture anyways,
        #   since we want all the macs at the other end. 

        #If the device is not layer 2 or 3, then we capture anyways.
        my $remote_ip = $dbports->{$port}->{remote_ip};
        if (defined $remote_ip and 
                (defined $OldDevices->{$remote_ip} or defined $Aliases->{$remote_ip})) {
            my $ip = defined $Aliases->{$remote_ip} ? $Aliases->{$remote_ip} : $remote_ip;
            my $layers = $OldDevices->{$ip};
        
            if (has_layer($layers,2) or has_layer($layers,3)){
                print "  ($mac) $port has neighbor: $remote_ip. Skipped.\n"
                    if $DEBUG;
                next;
            } else {
                print "  ($mac) $port has neighbor, but has layers $layers. Included.\n"
                    if $DEBUG;
            } 
        }

        # Check if Port Channel (patch from Derek Andree)
        if ($port =~ /port.channel/i) {
            print "  Port ($port) is a Port Channel Interface.  Skipped.\n" if $DEBUG;
            next;
        }
        
        # Check if MAC is a switch port
        if (defined $PortMAC->{$mac}) {
            my $switch_ip = $PortMAC->{$mac};
            if ($ip eq $switch_ip){
                print "  ($mac) Port on this switch.  Skipped.\n" if $DEBUG;
                next;
            } 

            print "   ($mac) Port:$port - Port on device $switch_ip. Included.\n"
                if $DEBUG;

            # TODO : This is an uplink port, mark here and have another process
            #        add a loopback if no topo info is there. 
            #        Also need some sort of process to show all the loopbacks

            # Removed to help debugging of topology info.  Uplink check should be enough.
            #next;  
        }

        # Check for Multicast MACs
        if ($mac =~ /^([0-9a-f]{2}):/i and ($1 =~ /.(1|3|5|7|9|b|d|f)/i)){
            print "  $mac:  MULTICAST\n" if $DEBUG;
            next;
        }

        next if $mac eq '00:00:00:00:00:00';
        next if uc($mac) eq 'FF:FF:FF:FF:FF:FF'; 

        if ($DEBUG) { 
            print "  $mac: $bp_id -> $iid -> $port\n";
        } else {
            print ".";
        }
        
        add_node($mac,$ip,$port); 
        $MacSeen{$mac}++;
    }
    print "\n" unless $DEBUG;
}

=back

=head2 NetBIOS Functions

=over

=item nbtstat(host) 

Connects to node and gets NetBIOS information. Then adds entries to node_nbt table.

Returns whether a node is answering netbios calls or not.

Based on Remo Rickli's nbtstat.pl

=cut

sub nbtstat {
    my $host = shift;
    my $port = 137;
    my $tout = 0.5;
    my $nbts = pack("C50",129,98,00,00,00,01,00,00,00,00,00,00,32,67,75,65,65,65,65,65,65,65,65,65,65,65,65,65,65,65,65,65,65,65,65,65,65,65,65,65,65,65,65,65,65,00,00,33,00,01);
    my ($wsnam, $data, $rin);
    my $sockaddr = 'S n a4 x8';                # magic
    my $family   = &Socket::AF_INET;    
    my $socktype = &Socket::SOCK_DGRAM;
    $wsnam = $data = $rin = '';

    print "nbtstat($host) : ";

    my ($name, $aliases, $type, $len, $peer_addr) = gethostbyname($host);
    my $ip=inet_ntoa($peer_addr);

    my $me   = pack($sockaddr, $family, 0, '');
    my $peer = pack($sockaddr, $family, $port, $peer_addr);

    socket(S, PF_INET, SOCK_DGRAM, getprotobyname('udp'))
         or die "Unable to create socket: $!";
    bind(S, $me) or die "Unable to bind socket: $!";
    send(S, $nbts, 0, $peer) or warn "Couldn't send: $!";

    # receive udp until timeout
    vec($rin, fileno(S), 1) = 1;
    while (select($rin, undef, undef, $tout)) {
        recv(S, $data, 1024, 0)        || die "recv: $!";
    }
    close(S);

    # Check for NetBIOS Info
    unless (length($data) > 70 and $data =~ /AAAAAAAAAA/) {  
        print "no Netbios.\n";
        return 0;
    }

    my $num = unpack("C",substr($data,56,1));    # Get number of names
    my $out = substr($data,57);            # get rid of WINS header
    my $server = 0;
    my $nbname = '';
    my $domain = '';
    my $nbuser = '';

    for (my $i = 0; $i < $num;$i++){
        my $nam = substr($out,18*$i,15);
        $nam =~ s/ +//g;
        # Skip IIS User 
        next if $nam =~ /IS~/;
        $nam =~ s/[^\d\w-]//g;

        my $id = unpack("C",substr($out,18*$i+15,1));
        my $fl = unpack("C",substr($out,18*$i+16,1));

        # Machine Name
        if ($id == 0 and $fl < 128){
            $nbname = $nbname || $nam;
        }
        # Domain or Workgroup
        elsif ($id ==0 and $fl >= 128){
            $domain = $nam;
        }
        # Server service
        elsif ($id eq "32") {
            $server = 1;
        }
        # User Logon
        elsif ($id eq "3"){
            $nbuser = $nam;
        }
    }

    my @mac = unpack("C6",substr($out,18*$num,6));
    my $mac = sprintf "%02X:%02X:%02X:%02X:%02X:%02X",@mac;

    unless ($nbname){
        print "No computer name found.\n";
        return 1;
    }

    if (!$mac or $mac eq '00:00:00:00:00:00'){
        # Just assume it's the last MAC we saw this IP at.
        $mac = sql_scalar('node_ip',['mac'],{'ip'=>$ip,'active'=>1});
        unless (defined $mac){
            print "No MAC in given or in DB.\n";
            return 1;
        }
        print "(No MAC)" if $DEBUG;
    }

    print "\\\\$domain\\$nbname $nbuser $mac ",$server ? 'server' : 'client', "\n";
    add_nbt($ip,$mac,$nbname,$domain,$server,$nbuser);
    $NbtTotal++;

    return 1;
}

=item nbtwalk() 

Visits every node and trys to get its NetBIOS information.  

Calls nbtstat() for each device.  

=cut

sub nbtwalk {
    $start_time = time;
    $NbtTotal=0;

    my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) = localtime();
    my $month = sprintf("%d%02d",$year+1900,$mon+1);
    &batch_mode("logs/$month/netbios",1);
    
    # Get nodes
    my $days = $CONFIG{nbt_days} || 7;
    print "Grabbing NetBIOS from all nodes seen in last $days days. (". localtime() . ")...\n";

    &load_old_nodes($days);
    print "  Searching ",scalar(keys(%$OldNodes))," nodes.\n" if $DEBUG;
    
    foreach my $node (sort sort_ip keys %$OldNodes){
        nbtstat($node) if defined $OldNodes->{$node};
    }
    
    sql_vacuum('node_nbt','print'=>1); 

    &end;
}

=back

=head2 Maintenance Functions

=over

=item alias_clean() 

Routine to clean out devices that are now listed as aliases of another device. This is
usually necessary after a device has been merged into another one.

=cut
sub alias_clean {
    print "Cleaning out Aliases that showed up as devices :\n";
    
    my $aliases = sql_rows('device_ip',['ip','alias','dns']);
    foreach my $row (@$aliases) {
        my $ip = $row->{ip};
        my $alias = $row->{alias};
        my $dns = $row->{dns};
        $dns = defined $dns ? $dns : '[No DNS]';
        my $exists = sql_scalar('device',['true'],{'ip'=>$alias});
        next unless (defined $exists and $exists);
        print "Deleting alias of $ip = $alias ($dns)\n";
        expire_device($alias,1)
    }

    print "Cleaning out Aliases of non-existant devices.\n";
    sql_do(qq/DELETE FROM device_ip WHERE ip NOT IN (SELECT ip FROM device)/);
}

=item arp_dump(dir) 

Dumps node_ip table to files arp_current and arp_archive.

=cut
sub arp_dump {
    my $dir = shift;

    print "Dumping node_ip table to $dir...\n";


    # Force to batch mode to not output to screen.
    my $old_batch = $BatchMode;
    $BatchMode=1;

    # Dump Current
    my $nodes = sql_rows('node_ip',['mac','ip as remote_ip','active',
                                    'extract(epoch from time_first) as time_first', 
                                    'extract(epoch from time_last) as time_last'],
                          {'active' => 1}
                        );

    &batch_mode("$dir/arp_current");
    foreach my $row (sort {sort_ip} @$nodes){
        my $active = $row->{active};
        next unless $active;
        my $mac = $row->{mac};  
        my $ip  = $row->{remote_ip};
        my $time_first = $row->{time_first};
        my $time_last = $row->{time_last};
        printf("%-15s  %-17s  %-10d %-10d\n",
            $ip, $mac, $time_first, $time_last);
    }
    &batch_mode_end;

    # Dump Archive
    $nodes = sql_rows('node_ip',['mac','ip as remote_ip','active',
                                    'extract(epoch from time_first) as time_first', 
                                    'extract(epoch from time_last) as time_last'],
                          {'active' => 0}
                           );
    &batch_mode("$dir/arp_archive");
    foreach my $row (sort {sort_ip} @$nodes){
        my $active = $row->{active};
        next if $active;
        my $mac = $row->{mac};  
        my $ip  = $row->{remote_ip};
        my $time_first = $row->{time_first};
        my $time_last = $row->{time_last};
        printf("%-15s  %-17s  %-10d %-10d\n",
            $ip, $mac, $time_first, $time_last);
    }
    &batch_mode_end;

    $BatchMode=$old_batch;

}

=item change_device_ip(from_ip, to_ip)

Used to move move over all the information from one device 
to a new IP address.  First tries to discover new device, then
proceeds to move over old information.  

=cut
sub change_device_ip {
    my ($from_ip,$to_ip) = @_;
    
    print "change_device_ip($from_ip,$to_ip)\n";

    return unless (defined $from_ip and defined $to_ip);

    &load_old_devices ;

    print "  Checking for Old Device ($from_ip)\n";
    unless (defined $OldDevices->{$from_ip}){
        print "  !$from_ip not found as device.\n";
        return 0;
    }

    if (defined $Aliases->{$from_ip}) {
        print "  !$from_ip is an alias. Using $Aliases->{$from_ip}.\n";
        $from_ip = $Aliases->{$from_ip};
    }
    
    &topo_load_file();

    print "  Adding New Device ($to_ip)\n";

    discover($to_ip); 

    &load_old_devices ;

    unless (defined $OldDevices->{$to_ip}){
        print "  !Device $to_ip did not discover.  Not moving old entries to this one. Fix and run again.\n";
        return 0;
    } 
    
    print "  Removing Old Device its Aliases, and Ports\n";
    expire_device($from_ip);
    
    print "  Moving old Nodes to New Device.\n";
    sql_do(qq/UPDATE node set switch='$to_ip' where switch='$from_ip'/);

    # TODO - Check to see if the port numbers have stayed the same, otherwise 
    #        axe the old nodes.

    return 1;
}

=item db_clean() 

Removes all the entries in C<node> that are switch ports. 

Checks for nodes on non existant ports and prints a warning

Removes nodes that are on uplink ports.

=cut
sub db_clean {
    print "Database Cleanup : \n";

    # See what devices exist
    &load_old_devices ;
    # Grab existing mac addresses for switch ports
    &mac_getportmacs;

    print "  Deleting nodes that are actually device ports...\n";
    # Delete MAC addresses that are ports on devices
    foreach my $mac (keys %$PortMAC){
        sql_do(qq/DELETE from node where mac = '$mac'/);
        sql_do(qq/DELETE from node_ip where mac = '$mac'/);
    }
    
    print "  Checking for Nodes that exist on non-existant ports:\n";
    my $NodeList = sql_rows('node',['mac','switch','port']);
    foreach my $row (@$NodeList){
        my $mac  = $row->{mac};  
        my $ip   = $row->{switch};
        my $port = $row->{port};
        
        my $have_device = defined $OldDevices->{$ip} ? 1 : 0;

        # If the device doesn't exist Delete it.
        # If the device exists and has ports, but not this port, delete the node
        # If the deviec exists and doesn't have ports, do not delete it.  Probably a refresh() error.
        my $nuke = 0;
        if ($have_device){
            my $have_port = sql_scalar('device_port',['1'],{'ip'=>$ip,'port'=>$port}) || 0;
            unless ($have_port){
                my $ports = sql_scalar('device_port',['count(*)'],{ip=>$ip});
                if (defined $ports and $ports){
                    print "    $mac \@ $ip/$port. Port no longer exists. Removed.\n";
                    $nuke++;
                } else {
                    print "    $mac \@ $ip/$port. Device has no ports.  Run -e $ip if appropriate.\n";
                }
            }
        } else  {
            print "    $mac \@ $ip/$port. Device no longer exists. Removed.\n";
            $nuke++;
        }

        if ($nuke) {
            #print "nuking $mac $ip $port\n" if $DEBUG;
            sql_do(qq/DELETE from node where mac = '$mac' and switch = '$ip' and port = '$port'/);
        }
    }

    &load_old_devices;
    print("  Removing nodes that are listed on uplink ports...\n");
    my $dev_ports = sql_rows('device_port',['ip','port'],{'remote_ip' => 'IS NOT NULL'});

    foreach my $dev_port (@$dev_ports){
        my $ip   = $dev_port->{ip};
        my $port = $dev_port->{port};
        $ip      = defined $Aliases->{$ip} ? $Aliases->{$ip} : $ip;
        my $layers = $OldDevices->{$ip};
        
        next unless defined $layers;
        # If Neighbor is not part of topology, leave it.
        if (has_layer($layers,2) or has_layer($layers,3)){
            sql_do(qq/DELETE FROM node WHERE switch='$ip' and port='$port'/);
        }
    }
    print "Done.\n"; 

    &expire_ips;
    sql_vacuum('node','print'=>1);
}

=item dev_dump() 

Dumps out the device,device_ip, and topology info from device_port to file 'devices'.

=cut
sub dev_dump {
    my $dir = shift;

    print "Dumping device and device_port tables to $dir...\n";

    # Force to batch mode to not output to screen.
    my $old_batch = $BatchMode;
    $BatchMode=1;
    
    &load_old_devices;
    
    &batch_mode("$dir/devices");

    # Make alias map
    my %alias_map;
    foreach my $alias (keys %$Aliases){
        my $dev = $Aliases->{$alias};

        push @{$alias_map{$dev}},$alias;
    }

    foreach my $dev (sort {sort_ip} keys %$OldDevices){
        print "$dev\n";
        if (defined $alias_map{$dev}){
            foreach my $alias (sort {sort_ip} @{$alias_map{$dev}}){
                print "\talias:$alias\n";
            }
        }

        # topology
        my $neighbors = sql_rows('device_port',['remote_ip','remote_port','port'],
                                {'remote_ip'=>'is not null','ip'=>$dev});

        foreach my $neighbor (sort {sort_ip} @$neighbors){

            my $port = $neighbor->{port};
            my $remote_ip = $neighbor->{remote_ip};
            my $remote_port = $neighbor->{remote_port};
            print "\tlink:$port,$remote_ip,$remote_port\n";
        }
    }

    &batch_mode_end;

    $BatchMode=$old_batch;
}

=item expire_data(type,days,archive_only)

C<type> can be : node,device

C<days> is a positive integer number of days in which an entry
has not been updated.

C<archive_only> for node only.

Removes devices and nodes that haven't been updated in C<days> days.
Called from nightly() and controlled through the C<expire_*> directives
in the config file.

Cheers to Brian Wilson for his patch for the start of this feature.

=cut
sub expire_data {
    my ($type, $days, $archive_only) = @_;
    $archive_only ||=0;

    unless (defined $type and $type =~ /^(node|device)$/i){
        print "expire_data : Data type (1st argument) must be either node or device.\n";
        return;
    }
    
    unless (defined $days and $days =~ /^\d+$/ and $days > 0){
        print "expire_data : Age of data must be a positive number of days (2nd argument).\n";
        return;
    }
    
    print "expire_data($type,$days days,archive_only:$archive_only)\n";

    if ($type eq 'device'){
        my $devices = sql_rows('device',['ip','dns','age(last_discover) as age'],
                               {'age(last_discover)' => \\ "> interval '$days days'"}
                              );
        foreach my $dev (sort {sort_ip} @$devices){
            my $name = $dev->{dns} || $dev->{ip};
            printf("Removing %-15s %25s   Last Seen: %s\n",$dev->{ip},$name,$dev->{age});

            # TODO - Ping device first.  Some devices stop responding to SNMP but still exist.
            #        then issue warning and don't delete?

            expire_device($dev->{ip},1);
        }   
    }

    if ($type eq 'node'){
        my $sql = qq/DELETE FROM node WHERE AGE(time_last) > INTERVAL '$days days'/;
        $sql .= " AND NOT active" if $archive_only;

        my $rows = '';
        $rows = sql_do($sql);

        # note:expire_ips() should be run after this, and is in nightly() through db_clean()
        print "Deleted $rows rows from node.\n";

        $sql = qq/DELETE from node_ip where age(time_last) > interval '$days days'/;
        $sql .= " AND NOT active" if $archive_only;
        
        $rows = sql_do($sql);
        print "Deleted $rows rows from node_ip.\n";

        $sql = qq/DELETE from node_nbt where age(time_last) > interval '$days days'/;
        $sql .= " AND NOT active" if $archive_only;
        
        $rows = sql_do($sql);
        print "Deleted $rows rows from node_nbt.\n";
    }
}

=item expire_device(device,expire_nodes?)

Removes device from the database

Set second argument to true to remove all the connected nodes and their 
IP mappings as well.

=cut
sub expire_device {
    my ($devname,$expire_nodes) = @_;
    my $ip  = getip($devname);

    print "Expire Device $devname ($ip)\n";

    unless (length $ip) {
        print "  Device $devname doesn't resolve.\n";
        return;
    }

    my $dev = sql_hash('device',['*'],{'ip'=>$ip} );

    unless (defined $dev){
        print "  Device $devname ($ip) not found in database!\n";
        return;
    }

    my $dns = $dev->{dns} || '';
    print "  Removing $dns ($ip)...\n";
    # Get rid of device info
    sql_do(qq/DELETE from device where ip = '$ip'/);
    print "  Removing Aliases of $dns ($ip)...\n";
    # Get rid of aliases
    sql_do(qq/DELETE from device_ip where ip = '$ip'/);
    # Remove Ports
    sql_do(qq/DELETE from device_port where ip = '$ip'/);

    if (defined $expire_nodes and $expire_nodes){
      &expire_nodes($ip);  
    }

}

=item expire_nodes(device,archive_only,port)

Removes entries from node and node_ip for a given device.

Set port to limit the expiration to a specific port.

Set archive_only to 1 to archive the nodes on the device.

=cut
sub expire_nodes {
    my ($dev,$archive,$port) = @_;
    my $ip  = getip($dev);

    print "Expire Nodes($dev)\n";
    unless (length $ip) {
        print "  Device $dev doesn't resolve.\n";
        return;
    }

    my %where_hash = ('switch' => $ip);
    my $where = "switch='$ip'";
    $where .= " AND port='$port'" if defined $port; 
    $where_hash{port} = $port if defined $port;
    
    # grab mac count
    my $macs = sql_rows('node',['count(mac)'],\%where_hash,undef,"GROUP BY mac");
     
    my $count = $macs->[0]->{count} || 0;
    if (defined $archive and $archive){
        # De-activate nodes
        print "  Archiving $count entries for $where\n";
        sql_do(qq/UPDATE node SET active=false WHERE $where/);
    } else {
        # Delete nodes
        print "  Deleting $count entries for $where\n";
        sql_do(qq/DELETE FROM node WHERE $where/);
    }
}

=item expire_nodes_subnet(subnet)

Subnet is in CIDR format, or any other format that Postgres likes.

    192.168.0.0/24

Runs expire_ips afterwards to cleanup.

=cut
sub expire_nodes_subnet {
    my $subnet  = shift;
    my $confirm = shift;
    
    print "expire_nodes_subnet($subnet)\n";
    my $dbsubnet = dbh_quote($subnet);

    my $devices = sql_rows('device',['ip','dns','location'],{'ip' => \\"<< $dbsubnet"});

    unless (defined $devices and scalar @$devices){
        print "No devices found in subnet $subnet.\n";
        print "Are you sure you specified the subnet CIDR format? Eg. 192.168.0.0/24\n";
        return;
    }

    print "Found Matching Devices : \n";
    foreach my $dev (sort { ($a->{dns}||$a->{ip}) cmp ($b->{dns}||$b->{ip}) } @$devices){
        my $name = $dev->{dns} || $dev->{ip};
        $name =~ s/\Q$CONFIG{domain}\E//;
        my $ip   = $dev->{ip};
        my $location = $dev->{location} || '';
        printf "  %-15s %-15s %s\n",$ip, substr($name,0,15), substr($location,0,46);
    }

    my $dev_count = scalar(@$devices);

    unless (defined $confirm){
        print "Enter 'delete' to confirm Exipration of nodes on these $dev_count devices.\n";
        print "Confirm : ";
        $confirm = <STDIN>;
        chomp $confirm;               
    } 
    
    unless ($confirm eq 'delete'){
        print "Never Mind.\n";
        return;
    }

    foreach my $dev (@$devices){
        my $ip = $dev->{ip};
        expire_nodes($ip);
    }

    &expire_ips;

}

=item expire_ips()

Expires IPs not in use in node or device_port

 select i.mac from node_ip i where 
    not exists 
        (select 1 from node n where n.mac = i.mac limit 1 ) 
    and 
    not exists 
        (select 1 from device_port p where p.mac = i.mac limit 1) 
 group by i.mac;

=cut
sub expire_ips {
    print "expire_ips()\n";
    my $sql = 'DELETE FROM node_ip WHERE mac IN ';
    $sql   .= '(SELECT i.mac FROM node_ip i WHERE';
    $sql   .= ' NOT EXISTS (SELECT 1 FROM node n WHERE n.mac = i.mac LIMIT 1)';
    $sql   .= ' AND';
    $sql   .= ' NOT EXISTS (SELECT 1 FROM device_port p WHERE p.mac = i.mac LIMIT 1)';
    $sql   .= ')';
            
    $DEBUG and print "\n\n  $sql\n";
    my $rows;
    $rows = sql_do($sql);
    $rows = $rows || 0;
    print "Deleted $rows rows.\n";
    sql_vacuum('node_ip','print'=>1);
}

=item mac_dump() 

Dumps the node table out to mac_current.txt and mac_archive.txt.
Adds a day stamp, no time-stamp.

May need to be changed if $nodes takes up too much memory.

=cut
sub mac_dump {
    my $dir=shift;

    print "Dumping node table to $dir...\n";

    # Force to batch mode to not output to screen.
    my $old_batch = $BatchMode;
    $BatchMode=1;

    # Dump Current
    my $nodes = sql_rows('node',['mac','switch','port','active',
                                    'extract(epoch from time_first) as time_first', 
                                    'extract(epoch from time_last) as time_last'],
                           {'active' => 1}
                        );

    &batch_mode("$dir/mac_current");

    foreach my $row (sort {$a->{mac} cmp $b->{mac}} @$nodes){
        my $active = $row->{active};
        next unless $active;
        my $mac = $row->{mac};  
        my $ip  = $row->{switch};
        my $port = $row->{port};
        my $time_first = $row->{time_first};
        my $time_last = $row->{time_last};
        printf("%-17s  %-15s  %-25s %-10d %-10d\n",
            $mac, $ip, $port, $time_first, $time_last);
    }
    &batch_mode_end;

    # Dump Archive
    $nodes = sql_rows('node',['mac','switch','port','active',
                                    'extract(epoch from time_first) as time_first', 
                                    'extract(epoch from time_last) as time_last'],
                           {'active' => 0}
                           );

    &batch_mode("$dir/mac_archive");

    foreach my $row (sort {$a->{mac} cmp $b->{mac}} @$nodes){
        my $active = $row->{active};
        next if $active;
        my $mac = $row->{mac};  
        my $ip  = $row->{switch};
        my $port = $row->{port};
        my $time_first = $row->{time_first};
        my $time_last = $row->{time_last};
        printf("%-17s  %-15s  %-25s %-10d %-10d\n",
            $mac, $ip, $port, $time_first, $time_last);
    }

    &batch_mode_end;

    $BatchMode=$old_batch;
}

=item netbios_dump() 

Dumps the node_nbt table out to netbios_current.txt and netbios_archive.txt.
Adds a day stamp, no time-stamp.

May need to be changed if $nodes takes up too much memory.

=cut
sub netbios_dump {
    my $dir=shift;

    print "Dumping node_nbt table to $dir...\n";

    # Force to batch mode to not output to screen.
    my $old_batch = $BatchMode;
    $BatchMode=1;

    # Dump Current
    my $nodes = sql_rows('node_nbt',['mac','nbname','domain','server','nbuser','active',
                                    'extract(epoch from time_first) as time_first', 
                                    'extract(epoch from time_last) as time_last'],
                           {'active' => 1}
                        );

    &batch_mode("$dir/netbios_current");

    foreach my $row (sort {$a->{mac} cmp $b->{mac}} @$nodes){
        my $active = $row->{active};
        next unless $active;
        my $mac    = $row->{mac};  
        my $name   = $row->{nbname};
        my $domain = $row->{domain};
        my $server = $row->{server};
        my $user   = $row->{nbuser};
        my $time_first = $row->{time_first};
        my $time_last = $row->{time_last};
        printf("%-17s  %-16s  %-16s %-1d %-16s %-10d %-10d\n",
            $mac, $name, $domain, $server, $user, $time_first, $time_last);
    }
    &batch_mode_end;

    # Dump Archive
    $nodes = sql_rows('node_nbt',['mac','nbname','domain','server','nbuser','active',
                                    'extract(epoch from time_first) as time_first', 
                                    'extract(epoch from time_last) as time_last'],
                           {'active' => 0}
                           );

    &batch_mode("$dir/netbios_archive");

    foreach my $row (sort {$a->{mac} cmp $b->{mac}} @$nodes){
        my $active = $row->{active};
        next if $active;
        my $mac    = $row->{mac};  
        my $name   = $row->{nbname};
        my $domain = $row->{domain};
        my $server = $row->{server};
        my $user   = $row->{nbuser};
        my $time_first = $row->{time_first};
        my $time_last = $row->{time_last};
        printf("%-17s  %-16s  %-16s %-1d %-16s %-10d %-10d\n",
            $mac, $name, $domain, $server, $user, $time_first, $time_last);
    }

    &batch_mode_end;

    $BatchMode=$old_batch;
}

=item nightly(no_batch)

Nightly maintance routine that creates backups of the device,node, and node_ip tables. 

Calls mac_dump(), arp_dump(), and dev_dump(), db_clean() and VACUUM ANALYZE

=cut
sub nightly {
    my $no_batch = shift || 0;
    print "nightly() - Starting nightly cleanup and backup routines\n";
    # Log backup
    my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) = localtime();
    my $month = sprintf("%d%02d",$year+1900,$mon+1);
    &batch_mode("logs/$month/nightly",1) unless (defined $no_batch and $no_batch);

    print "  Cleaning and clearing data...\n";

    # Expire Devices that are X days old
    if (defined $CONFIG{expire_devices} and $CONFIG{expire_devices} =~ /^\d+$/
        and $CONFIG{expire_devices} > 0) 
    {
        print "  expire_devices: Deleting Devices that are older than $CONFIG{expire_devices} days old.\n\n";
        expire_data('device',$CONFIG{expire_devices});
    }
    
    # Expire Archived Node Data X days old
    if (defined $CONFIG{expire_nodes_archive} and $CONFIG{expire_nodes_archive} =~ /^\d+$/
        and $CONFIG{expire_nodes_archive} > 0) 
    {
        print "  expire_nodes_archive: Deleting Archived Node data older than $CONFIG{expire_nodes_archive} days old.\n\n";
        expire_data('node',$CONFIG{expire_nodes_archive},1);
    }

    # Expire Nodes that are X days old
    if (defined $CONFIG{expire_nodes} and $CONFIG{expire_nodes} =~ /^\d+$/
        and $CONFIG{expire_nodes} > 0) 
    {
        print "  expire_nodes: Deleting Nodes older than $CONFIG{expire_nodes} days old.\n\n";
        expire_data('node',$CONFIG{expire_nodes});
    }
    
    # This will clean all node entries on unused ports and uplinks etc. Also runs expire_ips()
    &db_clean;

    my $datadir = $CONFIG{datadir} || 'data';
    $datadir = "$CONFIG{home}/$datadir";
    print "  Backing up Data to $datadir\n";

    die "Can't write to Data Directory.\n" unless -w $datadir;

    # batch_mode() now makes the dir for us. 
    #system("mkdir -m 0775 -p $datadir/mac/$month") unless (-d "$datadir/mac/$month");
    #system("mkdir -m 0775 -p $datadir/arp/$month") unless (-d "$datadir/arp/$month");
    #system("mkdir -m 0775 -p $datadir/dev/$month") unless (-d "$datadir/dev/$month");

    &nmis_dump;

    &mac_dump("mac/$month");

    &arp_dump("arp/$month");

    &dev_dump("dev/$month");

    &netbios_dump("netbios/$month");

    print "  Running Database Vacuum...\n";
    sql_vacuum('','print'=>1);

    &batch_mode_end unless $no_batch;
}

=item nmis_dump()

Dumps the device table out to NMIS (http://www.sins.com.au/nmis/) style config file.

=cut
sub nmis_dump {
    
    my $dump_file = $CONFIG{nmis_dump};
    unless (defined $dump_file){
        $DEBUG and print "nmis_dump() Config option nmis_dump not set.\n";
        return;
    }

    print "nmis_dump() - Dumping to $dump_file.csv \n";

    # Force to batch mode to not output to screen.
    local $CONFIG{logextension} = 'csv';
    my $old_batch = $BatchMode;
    $BatchMode=1;
    &batch_mode($dump_file,0,1);    # no header, no timestamp
print << "end_print";
#
# Netdisco - NMIS config file dump
#
# Header
#
node	community	snmpport	net	devicetype	role	group	collect	active
#
# Data
#
end_print
    my $devices = sql_rows('device',['ip','dns','snmp_comm','layers']);

    foreach my $dev (sort { ($a->{dns}||$a->{ip}) cmp ($b->{dns}||$b->{ip}) } @$devices){
        my $ip = $dev->{ip};
        my $layers = $dev->{layers};
        my $device_type = 'switch';
           $device_type = 'router' if has_layer($layers,3);
        my $node        = $dev->{dns}           || $ip;
        my $community   = $dev->{snmp_comm}     || 'public';
        my $snmpport    = $CONFIG{nmis_port}    || 161;
        my $net         = $CONFIG{nmis_net}     || 'lan';
        my $role        = $CONFIG{nmis_role}    || 'core';
        my $group       = $CONFIG{nmis_group}   || 'Network';
        my $collect     = $CONFIG{nmis_collect} || 'true'; 
        my $active      = $CONFIG{nmis_active}  || 'true';
        print join("\t",($node,$community,$snmpport,$net,$device_type,$role,$group,$collect,$active)),"\n";
    }
    batch_mode_end(1);      # dont compress
    $BatchMode=$old_batch;

}

=back

=head2 Graphing Functions

=over

=item graph(no_batch) 

Creates netmap of network.  Calls Netdisco::make_graph() and graph_each()

=cut
sub graph {
    my $no_batch = shift || 0;

    my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) = localtime();
    my $month = sprintf("%d%02d",$year+1900,$mon+1);
    &batch_mode("logs/$month/graph") unless $no_batch;
    print "graph() - Creating Graphs.\n";

    eval "use GraphViz;";
    if ($@) {
        my $err = $@;
        $err =~ s/\n/ /g;
        print "  GraphViz module not installed. See INSTALL.\n";
        print "  Error Reported : $err\n";
        print "\n\nGraphn not created.\n";
        return;
    }

    my $G = make_graph();

    unless (defined $G){
        print "graph() - make_graph() failed.  Try running with debug (-D)\n";
        return;
    }

    my @S = $G->strongly_connected_components;

    # Count number of nodes in each subgraph
    my %S_count;
    for (my $i=0;$i< scalar @S;$i++){
        $S_count{$i} = scalar @{$S[$i]};
    }
    
    foreach my $subgraph (sort { $S_count{$b} <=> $S_count{$a} } keys %S_count){
        my $SUBG = $G->copy;
        print "\$S[$subgraph] has $S_count{$subgraph} nodes.\n";
        
        # Remove other subgraphs from this one
        my %S_notme = %S_count;
        delete $S_notme{$subgraph};
        foreach my $other (keys %S_notme){ 
            print "Removing Non-connected nodes: ",join(',',@{$S[$other]}),"\n";
            $SUBG->delete_vertices(@{$S[$other]})
        }
        
        # Create the subgraph
        my $timeout = defined $CONFIG{graph_timeout} ? $CONFIG{graph_timeout} : 60;

        eval {
            alarm($timeout*60);
            graph_each($SUBG,'');
            alarm(0);
        };
        if ($@ =~ /timeout/i ){
            print "! Creating Graph timed out!\n";
        }
        
        # Facility to create subgraph for each non-connected network segment.  
        # Right now, let's just make the biggest one only.
        last;
    }

    &batch_mode_end unless $no_batch;
}

=item graph_each(Graph_obj, name) 

Generates subgraph. Called from graph().  Calls graph_node().  

Does actual GraphViz calls.

=cut
sub graph_each  {
    my ($G,$name) = @_;

    print "Creating new Graph\n";

    my $graph_defs = {
                     'bgcolor' => $CONFIG{graph_bg},
                     'color'   => $CONFIG{graph_color},
                     'overlap' => $CONFIG{graph_overlap} || 'false',
                     'fontpath'=> $CONFIG{home},
                     'ranksep' => $CONFIG{graph_ranksep},
                     'nodesep' => $CONFIG{graph_nodesep},
                     'splines' => $CONFIG{graph_splines} ? 'true' : 'false',
                     'ratio'   => 'compress'
                     };
    my $node_defs = { 
                    'shape'     => $CONFIG{node_shape},
                    'fillcolor' => $CONFIG{node_fillcolor},
                    'fontcolor' => $CONFIG{node_fontcolor},
                    'style'     => $CONFIG{node_style},
                    'fontname'  => $CONFIG{node_font},
                    'fontsize'  => $CONFIG{node_fontsize},
                    'fixedsize' => 'true'
                    };
    my $edge_defs = {
                    'color' => $CONFIG{edge_color}
                    };

    my $epsilon = undef;
    if (defined $CONFIG{graph_epsilon}){
        $epsilon = "0." . '0' x $CONFIG{graph_epsilon} . '1';
    }
    
    my %gv = (
               directed => 0,
               layout   => $CONFIG{graph_layout},
               graph => $graph_defs,
               node => $node_defs,
               edge => $edge_defs,
               width => $CONFIG{graph_x},
               height => $CONFIG{graph_y},
               epsilon => $epsilon,
              );

    my $gv = new GraphViz(%gv);

    my @nodes = $G->vertices;
    foreach my $dev (@nodes){
        graph_addnode($gv,$dev);
    }

    my @edges = $G->edges;

    while (scalar @edges){
        my $link = shift @edges;
        my $dest = shift @edges;
        my $speed = $netdisco::GRAPH_SPEED{$link}->{$dest}->{speed};
        print "  ! No link speed for $link -> $dest\n" unless defined $speed;
        #print "$link $dest $speed\n";
        #my %edge = ( dir => 'none' );
        my %edge = ();
        my $val = ''; my $suffix = '';
        if ($speed =~ /^([\d.]+)\s+([a-z])bps$/i) {
            $val = $1; $suffix = $2;
        }
        #print "\t $val $suffix\n";
        if ( ($suffix eq 'k') or ($speed =~ m/(t1|ds3)/i) ){
            $edge{color} = 'green';
            $edge{style} = 'dotted';
        }
        if ($suffix eq 'M'){
            if ($val < 10.0){
                $edge{color} = 'green';
                #$edge{style} = 'dotted';
                $edge{style} = 'dashed';
            } elsif ($val < 100.0){
                $edge{color} = '#8b7e66'; 
                #$edge{style} = 'normal';
                $edge{style} = 'solid';
            } else {
                $edge{color} = '#ffe7ba';
                $edge{style} = 'solid';
            }
        }
        if ($suffix eq 'G'){
            #$edge{style} = 'bold';
            $edge{color} = 'cyan1';
        }

        $gv->add_edge($link => $dest, %edge );
    }

    if (defined $CONFIG{graph_raw} and $CONFIG{graph_raw}){
        my $graph_raw = "$CONFIG{home}/$CONFIG{graph_raw}";
        print "  Creating raw graph: $graph_raw\n";
        $gv->as_canon($graph_raw);
    }
    if (defined $CONFIG{graph} and $CONFIG{graph}){
        my $graph_gif = "$CONFIG{home}/$CONFIG{graph}";
        print "  Creating graph: $graph_gif \n";
        $gv->as_gif($graph_gif);
    }
    if (defined $CONFIG{graph_map} and $CONFIG{graph_map}){
        my $graph_map = "$CONFIG{home}/$CONFIG{graph_map}";
        print "  Creating ISMAP : $graph_map\n";
        $gv->as_ismap($graph_map);
    }

    if (defined $CONFIG{graph_svg} and $CONFIG{graph_svg}){
        my $graph_svg = "$CONFIG{home}/$CONFIG{graph_svg}";
        print "  Creating SVG : $graph_svg\n";
        $gv->as_svg($graph_svg);
    }
}

=item graph_addnode(graphviz_obj,node_ip) 

Checks for mapping settings in config file and adds node to the GraphViz object.

=cut
sub graph_addnode {
    my $gv = shift;
    # non lexical on purpose
    use vars qw/$ip $label $isdev/;
    $ip    = shift;
    $label = $netdisco::GRAPH{$ip}->{dns};
    $isdev = $netdisco::GRAPH{$ip}->{isdev};

    my %node = ();

    $label = "($ip)" unless defined($label);
    my $domain = $CONFIG{domain};
    $label =~ s/\Q$domain\E//;
    # hack
    $label =~  s/\.resnet//;

    $node{label} = $label;

    # URL for image maps
    if ($isdev) {
        $node{URL} = "device.html?ip=$ip";
    } else {
        $node{URL} = "node.html?node=$ip";
        $node{fillcolor} = $CONFIG{node_problem};
    }

    # Dereferencing the scalar by name below
    #   requires that the variable be non-lexical (not my)
    #   we'll create some local non-lexical versions 
    #   that will expire at the end of this block
    # Node Mappings
    foreach my $map (@{$CONFIG{node_map}}){
        my ($var,$regex,$attr,$val) = split(':',$map);

        { no strict 'refs';
           $var =  ${"$var"}; 
        }

        next unless defined $var;

        if ($var =~ /$regex/) {
            print "Giving node $ip $attr = $val\n" if $DEBUG;
            $node{$attr} = $val;
        }
    }

    $gv->add_node($ip, %node);
}

=back

=head2 Admin Daemon

=over

=item admin_daemon_ctl(cmd)

start,stop,restart,status

=cut
sub admin_daemon_ctl {
    my $cmd = shift;

    if ($cmd eq 'restart') {
        &admin_daemon_ctl('stop');
        &admin_daemon_ctl('start');
    }

    if ($cmd eq 'start'){
        &admin_daemon; 
    }

    if ($cmd eq 'status'){
        my $status = &admin_daemon_status;
        if ($status) {
            print "Admin Daemon is running under pid $status.\n";
        } else {
            print "Admin Daemon is not currently running.\n";
        }
    }

    if ($cmd eq 'stop'){
        my $pid = &admin_daemon_status;
        if ($pid) {
            print "Stopping admin daemon ($pid).\n\n Waiting until current job completes ";
            kill INT => $pid;
            while(admin_daemon_status($pid)){
                print ".";
                sleep(1);
            }
            print "\n";
        } else {
            print "Admin daemon is not currently running!\n";
        }
    }

}

=item admin_daemon_status(pid)

Returns 0 if daemon is not running or returns pid number if running.

pid argument is optional, used in stop function

=cut
sub admin_daemon_status {
    my $pid = shift || &admin_daemon_pid;

    if (defined $pid){
        if (kill 0 => $pid) {
            print "Admin Daemon is already running. ($pid)\n" if $DEBUG;
            return $pid;
        } elsif ($! == EPERM) {             # changed uid
            warn "Admin Daemon ($pid) is running under another user, out of our control.\n";
            return $pid;
        } elsif ($! == ESRCH) {
            print "Admin Daemon ($pid) is deceased, starting new one.\n" if $DEBUG;  # or zombied
            return 0;
        } else {
            warn "No status of $pid: $!\n";
            return 0;
        }
    }
    return 0;
}

=item admin_daemon() 

Resident copy of netdisco to handle requests from the admin panel.

=cut
sub admin_daemon {
    my $pid = undef;
    # Check if we're already running
    if ($pid = &admin_daemon_status){
        print "Admin Daemon is already running. ($pid)\n";
        return;
    }

    $DaemonMode = 1;
    $BatchMode = 1;
    my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) = localtime();
    my $month = sprintf("%d%02d",$year+1900,$mon+1);
    &batch_mode("logs/$month/daemon",1);

    my $end_flag = 0;

    local %SIG;
    $SIG{INT} = $SIG{USR1} = $SIG{TERM} = 
        sub {$end_flag++;};
    $SIG{PIPE} = 'IGNORE';

    # Throw Daemon in bg if wanted.
    if (defined $CONFIG{daemon_bg} and $CONFIG{daemon_bg} ){
        die "Can't fork: $!\n" unless defined($pid = fork());
        # Exit parent thread
        exit if $pid;
        print "Running Daemon in Background.\n" if $DEBUG;
    }

    $pid = $$;
    print "Starting new admin panel daemon ($pid)\n";

    # Write out pid file
    &admin_daemon_pid($pid);

    my $poll_interval = $CONFIG{daemon_poll} || 2;

    # Create log dir
    my $datadir = $CONFIG{datadir};
    #system("mkdir -m 0775 -p $datadir/admin") unless (-d "$datadir/admin");

    # Mark left over jobs as bad
    sql_do("UPDATE admin SET status='error' WHERE status = 'running';"); 
    # hmm, looks like insert_or_update() doesnt work for this sort of thing, assumes insert cuz no cases exist.

    # Event Loop
    until ($end_flag){
        # TODO - Die if the database isn't there. 

        my $jobs = sql_rows('admin',['job','extract(epoch from entered) as entered',
                                     'device','action','status', 'username','debug','subaction',
                                     'port','userip','log'],
                            {'status' => 'queued'} );

        # Run each Job
        foreach my $job (sort {$a->{entered} <=> $b->{entered}} @$jobs) {
            admin_daemon_job($job);
            last if $end_flag;
        }

        sleep($poll_interval) unless $end_flag;
    }

    print "Daemon ending ($pid).\n";
}

=item admin_daemon_pid(pid_to_write)

If not supplied arguments, Reads pid of daemon pid from F<netdisco_daemon.pid>

If supplied arguments, writes the pid out to that file.

=cut
sub admin_daemon_pid {
    my $pid = shift;
    my $pid_file = $CONFIG{daemon_pid} || 'netdisco_daemon.pid';
    $pid_file = "$CONFIG{home}/$pid_file";

    if (defined $pid) {
        print "Writing pid:$pid to $pid_file\n" if $DEBUG;
        open (PIDFILE,"> $pid_file") or die "Can't open $pid_file. $!\n";
        print PIDFILE $pid;
        close (PIDFILE) or die "Can't write $pid_file. $!\n";
    } else {
        print "Reading pid from $pid_file\n" if $DEBUG;
        open (PIDFILE,"< $pid_file") or return undef;
        my $pid = (<PIDFILE>);
        chomp($pid);
        close (PIDFILE);
        return $pid;
    }
}

=item admin_daemon_job(job_obj)

Runs each job. Redirects output to data/admin/job-num-date.log
job_obj is the sql hash object for each job.

=cut
sub admin_daemon_job {
    my $job = shift;
    my $id     = $job->{job};
    my $cmd    = $job->{action};
    my $dev    = $job->{device};
    my $debug  = $job->{debug};
    my $subaction = $job->{subaction};

    print "Daemon: Working on job : $id\n" if $DEBUG;

    # Set to running
    insert_or_update('admin',{'job'=>$id },{'status'=>'running', 'started' => scalar(localtime)});

    # Capture output
    &batch_mode("admin/job-$id");
    my $old_debug = $DEBUG;
    $DEBUG = $debug;

    # Make sure we don't get our output yanked out from under us
    $BatchMode = 0;

    # Device tasks
    my $job_error = 0;
    if ($cmd eq 'macsuck') {
        &load_old_devices;
        &mac_getportmacs;
        &macsuck($dev);
    }

    elsif ($cmd eq 'arpnip') {
        &mac_getportmacs;
        &arpnip($dev);
    }

    elsif ($cmd eq 'refresh') {
        &topo_load_file;
        &discover($dev);
    }

    elsif ($cmd =~ /^delete(\+nodes)?$/) {
        my $del_nodes = $1 eq '+nodes' ? 1 : 0;
        &expire_device($dev,$del_nodes); 
    }

    elsif ($cmd =~ /^nodes-(del|arc)$/){
        my $subcmd = $1;
        my $port = $subaction;
        &expire_nodes($dev, $subcmd eq 'arc' ? 1 : 0, $port);
    }

    elsif ($cmd eq 'portcontrol'){
        $job_error = port_switch($job); 
    }

    # Discover Tasks

    elsif ($cmd eq 'discover'){
        &discover($subaction);
    }
    
    elsif ($cmd eq 'discover_run'){
        &run($subaction); 
    }

    elsif ($cmd eq 'discover_new'){
        local $New_Only = 1; 
        &run($subaction);
    }

    # Global Tasks
    elsif ($cmd eq 'expire_ips'){
        &expire_ips;
    }

    elsif ($cmd eq 'graph'){
        &graph(1);    
    }

    elsif ($cmd eq 'backup'){
        &nightly(1);
    }

    elsif ($cmd eq 'change_ip'){
        &change_device_ip($dev,$subaction);
    }

    elsif ($cmd eq 'clean_nodes'){
        &db_clean;
    }

    elsif ($cmd eq 'clean_alias'){
        &alias_clean;
    }
    
    else {
        print "Command $cmd not supported.\n";
        $job_error++;
    }

    # Clean Up
    $DEBUG = $old_debug;
    $BatchMode = 1;
    my $output_file = &batch_mode_end('no compress');
    open(OUTFILE, "<$output_file") or die "admin_daemon_job() Can't open $output_file. $!\n";

    # Slurp in log countents to a scalar.
    my $log = undef;
    {
        local $/ = undef;
        $log = <OUTFILE>;
    }
    close (OUTFILE);

    # Mark job done
    my $status = $job_error ? 'error' : 'done';
    insert_or_update('admin',{'job'=>$id },{'status'=>$status, 
                              'finished' => scalar(localtime), 'log'=>$log}
                    );
    return undef;
}

=back

=cut

sub test {
}

sub header{
    print "n e t  d i s c o\n";
    print '-'x50 . "\n";
}

sub version {
    &header;
    my $perl = defined $^V ? join('.',map {ord} split(//,$^V)) : $];
    print "Netdisco Version   : $VERSION\n";
    print "SNMP::Info Version : $SNMP::Info::VERSION\n";
    print "Net-SNMP Version   : $SNMP::VERSION\n";
    print "Perl Version       : $perl\n";
    exit;
}

sub usage{
    print <<"_end_usage_";
Netdisco - Network Discovery and Management ($VERSION)

netdisco [Options] Command(s)

Options:
    -b --batchmode              Batch Mode - Redirect stdout to log files
    -C --configfile   file      Specify path to config file
    -n --nodestoo               Delete nodes when using --expiredevice
    -N --newonly                For --discoverall and --discoverfile
    -P --port         port      Restrict --expirenodes to a single port 
    -V --archive                Archive instead of deleting in --expirenodes
    -D --debug                  DEBUG - Copious output
    -L --nologging              DEBUG - No logging
    -S --dumpsql                DEBUG - Dump SQL commands

Network Commands:
    -r --discoverall  device    Discover network starting from device
    -F --discoverfile file      Discover/Refresh devices from file
    -T --topofile               Import Topology info from topofile
    -R --refresh                Refresh all Devices
    -m --macwalk                Macsuck whole network
    -a --arpwalk                Arpnip whole network
    -w --nbtwalk                Nbtwalk whole network

Device Commands:
    -d --discover     device    Refresh single device
    -M --macsuck      device    Macsuck single device
    -A --arpnip       device    Arpnip  single device
    -W --nbtstat      node      Nbtstat single node
    -E --expiredevice device    Delete device
    -e --expirenodes  device    Delete/Archive nodes on a device
    --expire-nodes-subnet
                      subnet    Runs --expirenodes for all devices in a subnet
    -I --expireips              Expire IPs not seen on switch ports 
    -i --changeip     old new   Change IP address of device and its nodes

Administration:
    -B --backup                 Backups data and runs database cleanup 
    -g --graph                  Create network map files 
    -k --cleanalias             Deletes devices listed as aliases of another
    -K --cleannodes             Clean out nodes listed on uplink ports
    -O --oui                    Import oui.txt into Netdisco
    -p (start,stop,status,restart) Admin Daemon Control
    -u [user] [pw] [port] [admin]  Add/Change User 
    -v --version                Version info for Netdisco components

_end_usage_
    exit;
}

=head1 COPYRIGHT AND LICENCE

Changes in code from 0.92 on:
Copyright (c) 2003,2004 Max Baker - All Rights Reserved

Original Code:
Copyright (c) 2002,2003 Regents of the University of California
All rights reserved.

Redistribution and use in source and binary forms, with or without 
modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright notice,
      this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright notice,
      this list of conditions and the following disclaimer in the documentation
      and/or other materials provided with the distribution.
    * Neither the name of the University of California, Santa Cruz nor the 
      names of its contributors may be used to endorse or promote products 
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
